// This file is @generated by prost-build.
/// / An unsigned range interface to more accurately represent Rust native Range's
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Range {
    #[prost(uint64, tag = "1")]
    pub min: u64,
    #[prost(uint64, tag = "2")]
    pub max: u64,
}
/// / An Empty placeholder for endpoints without request parameters
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Empty {}
/// / Define an interface for block height
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeight {
    #[prost(uint64, tag = "1")]
    pub block_height: u64,
}
/// Define the explicit Signature implementation for the Minotari base layer. A different signature scheme can be
/// employed by redefining this type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Signature {
    #[prost(bytes = "vec", tag = "1")]
    pub public_nonce: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
/// Define the explicit ComAndPubSignature implementation for the Minotari base layer. A different signature scheme can be
/// employed by redefining this type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComAndPubSignature {
    #[prost(bytes = "vec", tag = "1")]
    pub ephemeral_commitment: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub ephemeral_pubkey: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub u_a: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub u_x: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub u_y: ::prost::alloc::vec::Vec<u8>,
}
/// Define the explicit CommitmentSignature implementation for the Minotari base layer. A different signature scheme can be
/// employed by redefining this type
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitmentSignature {
    #[prost(bytes = "vec", tag = "1")]
    pub public_nonce: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub u: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub v: ::prost::alloc::vec::Vec<u8>,
}
/// / PoW Algorithm constants
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PowAlgorithmConstants {
    #[prost(uint64, tag = "2")]
    pub min_difficulty: u64,
    #[prost(uint64, tag = "3")]
    pub max_difficulty: u64,
    #[prost(uint64, tag = "4")]
    pub target_time: u64,
}
/// / Weight params
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeightParams {
    #[prost(uint64, tag = "1")]
    pub kernel_weight: u64,
    #[prost(uint64, tag = "2")]
    pub input_weight: u64,
    #[prost(uint64, tag = "3")]
    pub output_weight: u64,
    #[prost(uint64, tag = "4")]
    pub features_and_scripts_bytes_per_gram: u64,
}
/// / Output version
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputsVersion {
    #[prost(message, optional, tag = "1")]
    pub outputs: ::core::option::Option<Range>,
    #[prost(message, optional, tag = "2")]
    pub features: ::core::option::Option<Range>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermittedRangeProofs {
    #[prost(enumeration = "OutputType", tag = "1")]
    pub output_type: i32,
    #[prost(enumeration = "RangeProofType", repeated, tag = "2")]
    pub range_proof_types: ::prost::alloc::vec::Vec<i32>,
}
/// / Range proof
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RangeProof {
    #[prost(bytes = "vec", tag = "1")]
    pub proof_bytes: ::prost::alloc::vec::Vec<u8>,
}
/// / Consensus Constants response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusConstants {
    #[prost(uint64, tag = "1")]
    pub coinbase_min_maturity: u64,
    #[prost(uint32, tag = "2")]
    pub blockchain_version: u32,
    #[prost(uint64, tag = "3")]
    pub future_time_limit: u64,
    #[prost(uint64, tag = "5")]
    pub difficulty_block_window: u64,
    #[prost(uint64, tag = "7")]
    pub max_block_transaction_weight: u64,
    #[prost(uint64, tag = "8")]
    pub pow_algo_count: u64,
    #[prost(uint64, tag = "9")]
    pub median_timestamp_count: u64,
    #[prost(uint64, tag = "10")]
    pub emission_initial: u64,
    #[prost(uint64, repeated, tag = "11")]
    pub emission_decay: ::prost::alloc::vec::Vec<u64>,
    #[deprecated]
    #[prost(uint64, tag = "12")]
    pub emission_tail: u64,
    #[prost(uint64, tag = "13")]
    pub min_sha3x_pow_difficulty: u64,
    #[prost(uint64, tag = "14")]
    pub block_weight_inputs: u64,
    #[prost(uint64, tag = "15")]
    pub block_weight_outputs: u64,
    #[prost(uint64, tag = "16")]
    pub block_weight_kernels: u64,
    #[prost(uint64, tag = "17")]
    pub pre_mine_value: u64,
    #[prost(uint64, tag = "18")]
    pub max_script_byte_size: u64,
    #[prost(uint64, tag = "19")]
    pub validator_node_validity_period: u64,
    #[prost(uint64, tag = "20")]
    pub effective_from_height: u64,
    #[prost(message, optional, tag = "21")]
    pub valid_blockchain_version_range: ::core::option::Option<Range>,
    #[prost(uint64, tag = "22")]
    pub max_randomx_seed_height: u64,
    #[prost(map = "uint32, message", tag = "23")]
    pub proof_of_work: ::std::collections::HashMap<u32, PowAlgorithmConstants>,
    #[prost(message, optional, tag = "24")]
    pub transaction_weight: ::core::option::Option<WeightParams>,
    #[prost(message, optional, tag = "26")]
    pub input_version_range: ::core::option::Option<Range>,
    #[prost(message, optional, tag = "27")]
    pub output_version_range: ::core::option::Option<OutputsVersion>,
    #[prost(message, optional, tag = "28")]
    pub kernel_version_range: ::core::option::Option<Range>,
    #[prost(enumeration = "OutputType", repeated, tag = "29")]
    pub permitted_output_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint64, tag = "30")]
    pub epoch_length: u64,
    #[prost(uint64, tag = "31")]
    pub validator_node_registration_min_deposit_amount: u64,
    #[prost(uint64, tag = "32")]
    pub validator_node_registration_min_lock_height: u64,
    #[prost(uint64, tag = "33")]
    pub validator_node_registration_shuffle_interval_epoch: u64,
    #[prost(message, repeated, tag = "34")]
    pub permitted_range_proof_types: ::prost::alloc::vec::Vec<PermittedRangeProofs>,
    #[prost(uint64, tag = "35")]
    pub inflation_bips: u64,
    #[prost(uint64, tag = "36")]
    pub tail_epoch_length: u64,
    #[prost(uint64, tag = "37")]
    pub max_block_coinbase_count: u64,
}
/// / Output types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OutputType {
    Standard = 0,
    Coinbase = 1,
    Burn = 2,
    ValidatorNodeRegistration = 3,
    CodeTemplateRegistration = 4,
}
impl OutputType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OutputType::Standard => "STANDARD",
            OutputType::Coinbase => "COINBASE",
            OutputType::Burn => "BURN",
            OutputType::ValidatorNodeRegistration => "VALIDATOR_NODE_REGISTRATION",
            OutputType::CodeTemplateRegistration => "CODE_TEMPLATE_REGISTRATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STANDARD" => Some(Self::Standard),
            "COINBASE" => Some(Self::Coinbase),
            "BURN" => Some(Self::Burn),
            "VALIDATOR_NODE_REGISTRATION" => Some(Self::ValidatorNodeRegistration),
            "CODE_TEMPLATE_REGISTRATION" => Some(Self::CodeTemplateRegistration),
            _ => None,
        }
    }
}
/// / Range proof types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RangeProofType {
    BulletproofPlus = 0,
    RevealedValue = 1,
}
impl RangeProofType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RangeProofType::BulletproofPlus => "BULLETPROOF_PLUS",
            RangeProofType::RevealedValue => "REVEALED_VALUE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BULLETPROOF_PLUS" => Some(Self::BulletproofPlus),
            "REVEALED_VALUE" => Some(Self::RevealedValue),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SideChainFeature {
    #[prost(oneof = "side_chain_feature::SideChainFeature", tags = "1, 2, 3")]
    pub side_chain_feature: ::core::option::Option<side_chain_feature::SideChainFeature>,
}
/// Nested message and enum types in `SideChainFeature`.
pub mod side_chain_feature {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SideChainFeature {
        #[prost(message, tag = "1")]
        ValidatorNodeRegistration(super::ValidatorNodeRegistration),
        #[prost(message, tag = "2")]
        TemplateRegistration(super::TemplateRegistration),
        #[prost(message, tag = "3")]
        ConfidentialOutput(super::ConfidentialOutputData),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorNodeRegistration {
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<Signature>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateRegistration {
    #[prost(bytes = "vec", tag = "1")]
    pub author_public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub author_signature: ::core::option::Option<Signature>,
    #[prost(string, tag = "3")]
    pub template_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub template_version: u32,
    #[prost(message, optional, tag = "5")]
    pub template_type: ::core::option::Option<TemplateType>,
    #[prost(message, optional, tag = "6")]
    pub build_info: ::core::option::Option<BuildInfo>,
    #[prost(bytes = "vec", tag = "7")]
    pub binary_sha: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "8")]
    pub binary_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfidentialOutputData {
    #[prost(bytes = "vec", tag = "1")]
    pub claim_public_key: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TemplateType {
    #[prost(oneof = "template_type::TemplateType", tags = "1, 2, 3")]
    pub template_type: ::core::option::Option<template_type::TemplateType>,
}
/// Nested message and enum types in `TemplateType`.
pub mod template_type {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TemplateType {
        #[prost(message, tag = "1")]
        Wasm(super::WasmInfo),
        #[prost(message, tag = "2")]
        Flow(super::FlowInfo),
        #[prost(message, tag = "3")]
        Manifest(super::ManifestInfo),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WasmInfo {
    #[prost(uint32, tag = "1")]
    pub abi_version: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlowInfo {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManifestInfo {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildInfo {
    #[prost(string, tag = "1")]
    pub repo_url: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub commit_hash: ::prost::alloc::vec::Vec<u8>,
}
/// The transaction kernel tracks the excess for a given transaction. For an explanation of what the excess is, and
/// why it is necessary, refer to the
/// [Mimblewimble TLU post](<https://tlu.tarilabs.com/protocols/mimblewimble-1/sources/PITCHME.link.html?highlight=mimblewimble#mimblewimble>).
/// The kernel also tracks other transaction metadata, such as the lock height for the transaction (i.e. the earliest
/// this transaction can be mined) and the transaction fee, in cleartext.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionKernel {
    /// Options for a kernel's structure or use
    #[prost(uint32, tag = "1")]
    pub features: u32,
    /// / Fee originally included in the transaction this proof is for (in MicroMinotari)
    #[prost(uint64, tag = "2")]
    pub fee: u64,
    /// This kernel is not valid earlier than lock_height blocks
    /// The max lock_height of all *inputs* to this transaction
    #[prost(uint64, tag = "3")]
    pub lock_height: u64,
    /// Remainder of the sum of all transaction commitments. If the transaction
    /// is well formed, amounts components should sum to zero and the excess
    /// is hence a valid public key.
    #[prost(bytes = "vec", tag = "6")]
    pub excess: ::prost::alloc::vec::Vec<u8>,
    /// The signature proving the excess is a valid public key, which signs
    /// the transaction fee.
    #[prost(message, optional, tag = "7")]
    pub excess_sig: ::core::option::Option<Signature>,
    /// The hash of the kernel, as it appears in the MMR
    #[prost(bytes = "vec", tag = "8")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// Version
    #[prost(uint32, tag = "9")]
    pub version: u32,
    /// Optional burned commitment
    #[prost(bytes = "vec", tag = "10")]
    pub burn_commitment: ::prost::alloc::vec::Vec<u8>,
}
/// A transaction input.
///
/// Primarily a reference to an output being spent by the transaction.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionInput {
    /// The features of the output being spent. We will check maturity for all outputs.
    #[prost(message, optional, tag = "1")]
    pub features: ::core::option::Option<OutputFeatures>,
    /// The commitment referencing the output being spent.
    #[prost(bytes = "vec", tag = "2")]
    pub commitment: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the input, as it appears in the MMR
    #[prost(bytes = "vec", tag = "3")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// The serialised script
    #[prost(bytes = "vec", tag = "4")]
    pub script: ::prost::alloc::vec::Vec<u8>,
    /// The script input data, if any
    #[prost(bytes = "vec", tag = "5")]
    pub input_data: ::prost::alloc::vec::Vec<u8>,
    /// A signature with k_s, signing the script, input data, and mined height
    #[prost(message, optional, tag = "7")]
    pub script_signature: ::core::option::Option<ComAndPubSignature>,
    /// The offset public key, K_O
    #[prost(bytes = "vec", tag = "8")]
    pub sender_offset_public_key: ::prost::alloc::vec::Vec<u8>,
    /// The hash of the output this input is spending
    #[prost(bytes = "vec", tag = "9")]
    pub output_hash: ::prost::alloc::vec::Vec<u8>,
    /// Covenant
    #[prost(bytes = "vec", tag = "10")]
    pub covenant: ::prost::alloc::vec::Vec<u8>,
    /// Version
    #[prost(uint32, tag = "11")]
    pub version: u32,
    /// The encrypted data
    #[prost(bytes = "vec", tag = "12")]
    pub encrypted_data: ::prost::alloc::vec::Vec<u8>,
    /// The minimum value of the commitment that is proven by the range proof (in MicroMinotari)
    #[prost(uint64, tag = "13")]
    pub minimum_value_promise: u64,
    /// The metadata signature for output this input is spending
    #[prost(message, optional, tag = "14")]
    pub metadata_signature: ::core::option::Option<ComAndPubSignature>,
    /// The rangeproof hash for output this input is spending
    #[prost(bytes = "vec", tag = "15")]
    pub rangeproof_hash: ::prost::alloc::vec::Vec<u8>,
}
/// Output for a transaction, defining the new ownership of coins that are being transferred. The commitment is a
/// blinded value for the output while the range proof guarantees the commitment includes a positive value without
/// overflow and the ownership of the private key.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionOutput {
    /// Options for an output's structure or use
    #[prost(message, optional, tag = "1")]
    pub features: ::core::option::Option<OutputFeatures>,
    /// The homomorphic commitment representing the output amount
    #[prost(bytes = "vec", tag = "2")]
    pub commitment: ::prost::alloc::vec::Vec<u8>,
    /// A proof that the commitment is in the right range
    #[prost(message, optional, tag = "3")]
    pub range_proof: ::core::option::Option<RangeProof>,
    /// The hash of the output, as it appears in the MMR
    #[prost(bytes = "vec", tag = "4")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// Tari script serialised script
    #[prost(bytes = "vec", tag = "5")]
    pub script: ::prost::alloc::vec::Vec<u8>,
    /// Tari script offset public key, K_O
    #[prost(bytes = "vec", tag = "6")]
    pub sender_offset_public_key: ::prost::alloc::vec::Vec<u8>,
    /// Metadata signature with the homomorphic commitment private values (amount and blinding factor) and the sender
    /// offset private key
    #[prost(message, optional, tag = "7")]
    pub metadata_signature: ::core::option::Option<ComAndPubSignature>,
    /// Covenant
    #[prost(bytes = "vec", tag = "8")]
    pub covenant: ::prost::alloc::vec::Vec<u8>,
    /// Version
    #[prost(uint32, tag = "9")]
    pub version: u32,
    /// Encrypted Pedersen commitment openings (value and mask) for the output
    #[prost(bytes = "vec", tag = "10")]
    pub encrypted_data: ::prost::alloc::vec::Vec<u8>,
    /// The minimum value of the commitment that is proven by the range proof (in MicroMinotari)
    #[prost(uint64, tag = "11")]
    pub minimum_value_promise: u64,
    /// Payment reference (PayRef) - 32-byte Blake2b hash of (block_hash || output_hash)
    /// This provides a unique, deterministic reference for the output that can be used
    /// for payment verification without revealing wallet ownership
    #[prost(bytes = "vec", tag = "12")]
    pub payment_reference: ::prost::alloc::vec::Vec<u8>,
}
/// Options for UTXOs
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputFeatures {
    /// Version
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// The type of output, eg Coinbase, all of which have different consensus rules
    #[prost(uint32, tag = "2")]
    pub output_type: u32,
    /// The maturity of the specific UTXO. This is the min lock height at which an UTXO can be spend. Coinbase UTXO
    /// require a min maturity of the Coinbase_lock_height, this should be checked on receiving new blocks.
    #[prost(uint64, tag = "3")]
    pub maturity: u64,
    /// Additional arbitrary info in coinbase transactions supplied by miners
    #[prost(bytes = "vec", tag = "4")]
    pub coinbase_extra: ::prost::alloc::vec::Vec<u8>,
    /// Features that are specific to a side chain
    #[prost(message, optional, tag = "5")]
    pub sidechain_feature: ::core::option::Option<SideChainFeature>,
    /// The type of range proof used in the output
    #[prost(uint32, tag = "6")]
    pub range_proof_type: u32,
}
/// The components of the block or transaction. The same struct can be used for either, since in Mimblewimble,
/// cut-through means that blocks and transactions have the same structure. The inputs, outputs and kernels should
/// be sorted by their Blake2b-256bit digest hash
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateBody {
    /// List of inputs spent by the transaction.
    #[prost(message, repeated, tag = "1")]
    pub inputs: ::prost::alloc::vec::Vec<TransactionInput>,
    /// List of outputs the transaction produces.
    #[prost(message, repeated, tag = "2")]
    pub outputs: ::prost::alloc::vec::Vec<TransactionOutput>,
    /// Kernels contain the excesses and their signatures for transaction
    #[prost(message, repeated, tag = "3")]
    pub kernels: ::prost::alloc::vec::Vec<TransactionKernel>,
}
/// A transaction which consists of a kernel offset and an aggregate body made up of inputs, outputs and kernels.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    #[prost(bytes = "vec", tag = "1")]
    pub offset: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AggregateBody>,
    #[prost(bytes = "vec", tag = "3")]
    pub script_offset: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnblindedOutput {
    /// Value of the output
    #[prost(uint64, tag = "1")]
    pub value: u64,
    /// Spending key of the output
    #[prost(bytes = "vec", tag = "2")]
    pub spending_key: ::prost::alloc::vec::Vec<u8>,
    /// Options for an output's structure or use
    #[prost(message, optional, tag = "3")]
    pub features: ::core::option::Option<OutputFeatures>,
    /// Tari script serialised script
    #[prost(bytes = "vec", tag = "4")]
    pub script: ::prost::alloc::vec::Vec<u8>,
    /// Tari script input data for spending
    #[prost(bytes = "vec", tag = "5")]
    pub input_data: ::prost::alloc::vec::Vec<u8>,
    /// Tari script private key
    #[prost(bytes = "vec", tag = "7")]
    pub script_private_key: ::prost::alloc::vec::Vec<u8>,
    /// Tari script offset pubkey, K_O
    #[prost(bytes = "vec", tag = "8")]
    pub sender_offset_public_key: ::prost::alloc::vec::Vec<u8>,
    /// UTXO signature with the script offset private key, k_O
    #[prost(message, optional, tag = "9")]
    pub metadata_signature: ::core::option::Option<ComAndPubSignature>,
    /// The minimum height the script allows this output to be spent
    #[prost(uint64, tag = "10")]
    pub script_lock_height: u64,
    /// Covenant
    #[prost(bytes = "vec", tag = "11")]
    pub covenant: ::prost::alloc::vec::Vec<u8>,
    /// Encrypted data
    #[prost(bytes = "vec", tag = "12")]
    pub encrypted_data: ::prost::alloc::vec::Vec<u8>,
    /// The minimum value of the commitment that is proven by the range proof (in MicroMinotari)
    #[prost(uint64, tag = "13")]
    pub minimum_value_promise: u64,
    /// The range proof
    #[prost(message, optional, tag = "14")]
    pub range_proof: ::core::option::Option<RangeProof>,
}
/// The BlockHeader contains all the metadata for the block, including proof of work, a link to the previous block
/// and the transaction kernels.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeader {
    /// The hash of the block
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// Version of the block
    #[prost(uint32, tag = "2")]
    pub version: u32,
    /// Height of this block since the genesis block (height 0)
    #[prost(uint64, tag = "3")]
    pub height: u64,
    /// Hash of the block previous to this in the chain.
    #[prost(bytes = "vec", tag = "4")]
    pub prev_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp at which the block was built.
    #[prost(uint64, tag = "5")]
    pub timestamp: u64,
    /// This is the UTXO merkle root of the outputs in the blockchain
    #[prost(bytes = "vec", tag = "6")]
    pub output_mr: ::prost::alloc::vec::Vec<u8>,
    /// This is the merkle root of all outputs in this block
    #[prost(bytes = "vec", tag = "7")]
    pub block_output_mr: ::prost::alloc::vec::Vec<u8>,
    /// This is the MMR root of the kernels
    #[prost(bytes = "vec", tag = "8")]
    pub kernel_mr: ::prost::alloc::vec::Vec<u8>,
    /// This is the Merkle root of the inputs in this block
    #[prost(bytes = "vec", tag = "9")]
    pub input_mr: ::prost::alloc::vec::Vec<u8>,
    /// Total accumulated sum of kernel offsets since genesis block. We can derive the kernel offset sum for *this*
    /// block from the total kernel offset of the previous block header.
    #[prost(bytes = "vec", tag = "10")]
    pub total_kernel_offset: ::prost::alloc::vec::Vec<u8>,
    /// Nonce increment used to mine this block.
    #[prost(uint64, tag = "11")]
    pub nonce: u64,
    /// Proof of work metadata
    #[prost(message, optional, tag = "12")]
    pub pow: ::core::option::Option<ProofOfWork>,
    /// Kernel MMR size
    #[prost(uint64, tag = "13")]
    pub kernel_mmr_size: u64,
    /// Output MMR size
    #[prost(uint64, tag = "14")]
    pub output_mmr_size: u64,
    /// Sum of script offsets for all kernels in this block.
    #[prost(bytes = "vec", tag = "15")]
    pub total_script_offset: ::prost::alloc::vec::Vec<u8>,
    /// Merkle root of validator nodes
    #[prost(bytes = "vec", tag = "16")]
    pub validator_node_mr: ::prost::alloc::vec::Vec<u8>,
    /// Validator size
    #[prost(uint64, tag = "17")]
    pub validator_node_size: u64,
}
/// The proof of work data structure that is included in the block header.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProofOfWork {
    /// The algorithm used to mine this block
    ///    0 = Monero
    ///    1 = Sha3X
    #[prost(uint64, tag = "1")]
    pub pow_algo: u64,
    /// Supplemental proof of work data. For example for Sha3x, this would be empty (only the block header is
    /// required), but for Monero merge mining we need the Monero block header and RandomX seed hash.
    #[prost(bytes = "vec", tag = "4")]
    pub pow_data: ::prost::alloc::vec::Vec<u8>,
}
/// This is used to request the which pow algo should be used with the block template
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PowAlgo {
    /// The pow algo to use
    #[prost(enumeration = "pow_algo::PowAlgos", tag = "1")]
    pub pow_algo: i32,
}
/// Nested message and enum types in `PowAlgo`.
pub mod pow_algo {
    /// The permitted pow algorithms
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PowAlgos {
        /// Accessible as `grpc::pow_algo::PowAlgos::RandomxM`
        Randomxm = 0,
        /// Accessible as `grpc::pow_algo::PowAlgos::Sha3x`
        Sha3x = 1,
        /// Accessible as `grpc::pow_algo::PowAlgos::RandomxT`
        Randomxt = 2,
    }
    impl PowAlgos {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PowAlgos::Randomxm => "POW_ALGOS_RANDOMXM",
                PowAlgos::Sha3x => "POW_ALGOS_SHA3X",
                PowAlgos::Randomxt => "POW_ALGOS_RANDOMXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "POW_ALGOS_RANDOMXM" => Some(Self::Randomxm),
                "POW_ALGOS_SHA3X" => Some(Self::Sha3x),
                "POW_ALGOS_RANDOMXT" => Some(Self::Randomxt),
                _ => None,
            }
        }
    }
}
/// A Minotari block. Blocks are linked together into a blockchain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    /// The BlockHeader contains all the metadata for the block, including proof of work, a link to the previous block
    /// and the transaction kernels.
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<BlockHeader>,
    /// The components of the block or transaction. The same struct can be used for either, since in Mimblewimble,
    /// blocks consist of inputs, outputs and kernels, rather than transactions.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AggregateBody>,
}
/// The representation of a historical block in the blockchain. It is essentially identical to a protocol-defined
/// block but contains some extra metadata that clients such as Block Explorers will find interesting.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistoricalBlock {
    /// The number of blocks that have been mined since this block, including this one. The current tip will have one
    /// confirmation.
    #[prost(uint64, tag = "1")]
    pub confirmations: u64,
    /// The underlying block
    #[prost(message, optional, tag = "2")]
    pub block: ::core::option::Option<Block>,
}
/// The NewBlockHeaderTemplate is used for the construction of a new mine-able block. It contains all the metadata for the block that the Base Node is able to complete on behalf of a Miner.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewBlockHeaderTemplate {
    /// Version of the block
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Height of this block since the genesis block (height 0)
    #[prost(uint64, tag = "2")]
    pub height: u64,
    /// Hash of the block previous to this in the chain.
    #[prost(bytes = "vec", tag = "3")]
    pub prev_hash: ::prost::alloc::vec::Vec<u8>,
    /// Total accumulated sum of kernel offsets since genesis block. We can derive the kernel offset sum for *this*
    /// block from the total kernel offset of the previous block header.
    #[prost(bytes = "vec", tag = "4")]
    pub total_kernel_offset: ::prost::alloc::vec::Vec<u8>,
    /// Proof of work metadata
    #[prost(message, optional, tag = "5")]
    pub pow: ::core::option::Option<ProofOfWork>,
    /// Sum of script offsets for all kernels in this block.
    #[prost(bytes = "vec", tag = "7")]
    pub total_script_offset: ::prost::alloc::vec::Vec<u8>,
}
/// The new block template is used constructing a new partial block, allowing a miner to added the coinbase utxo and as a final step the Base node to add the MMR roots to the header.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewBlockTemplate {
    /// The NewBlockHeaderTemplate is used for the construction of a new mineable block. It contains all the metadata for
    /// the block that the Base Node is able to complete on behalf of a Miner.
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<NewBlockHeaderTemplate>,
    /// This flag indicates if the inputs, outputs and kernels have been sorted internally, that is, the sort() method
    /// has been called. This may be false even if all components are sorted.
    #[prost(message, optional, tag = "2")]
    pub body: ::core::option::Option<AggregateBody>,
    /// Sometimes the mempool has not synced to the latest tip, this flag indicates if the mempool is out of sync.
    /// In most cases the next call to get_new_block_template will return a block with the mempool in sync.
    #[prost(bool, tag = "3")]
    pub is_mempool_in_sync: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeIdentity {
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "2")]
    pub public_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "3")]
    pub node_id: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Peer {
    /// / Public key of the peer
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// / NodeId of the peer
    #[prost(bytes = "vec", tag = "2")]
    pub node_id: ::prost::alloc::vec::Vec<u8>,
    /// / Peer's addresses
    #[prost(message, repeated, tag = "3")]
    pub addresses: ::prost::alloc::vec::Vec<Address>,
    /// / Last connection attempt to peer
    #[prost(uint64, tag = "4")]
    pub last_connection: u64,
    /// / Flags for the peer.
    #[prost(uint32, tag = "5")]
    pub flags: u32,
    #[prost(uint64, tag = "6")]
    pub banned_until: u64,
    #[prost(string, tag = "7")]
    pub banned_reason: ::prost::alloc::string::String,
    #[prost(uint64, tag = "8")]
    pub offline_at: u64,
    /// / Features supported by the peer
    #[prost(uint32, tag = "9")]
    pub features: u32,
    /// / used as information for more efficient protocol negotiation.
    #[prost(bytes = "vec", repeated, tag = "11")]
    pub supported_protocols: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// / User agent advertised by the peer
    #[prost(string, tag = "12")]
    pub user_agent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkStatusResponse {
    #[prost(enumeration = "ConnectivityStatus", tag = "1")]
    pub status: i32,
    #[prost(uint32, tag = "2")]
    pub avg_latency_ms: u32,
    #[prost(uint32, tag = "3")]
    pub num_node_connections: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub last_seen: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub connection_attempts: u32,
    #[prost(message, optional, tag = "5")]
    pub avg_latency: ::core::option::Option<AverageLatency>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AverageLatency {
    #[prost(uint64, tag = "1")]
    pub latency: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectedPeersResponse {
    #[prost(message, repeated, tag = "1")]
    pub connected_peers: ::prost::alloc::vec::Vec<Peer>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SoftwareUpdate {
    #[prost(bool, tag = "1")]
    pub has_update: bool,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub sha: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub download_url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIdentityRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIdentityResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub public_address: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub node_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConnectivityStatus {
    Initializing = 0,
    Online = 1,
    Degraded = 2,
    Offline = 3,
}
impl ConnectivityStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ConnectivityStatus::Initializing => "Initializing",
            ConnectivityStatus::Online => "Online",
            ConnectivityStatus::Degraded => "Degraded",
            ConnectivityStatus::Offline => "Offline",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Initializing" => Some(Self::Initializing),
            "Online" => Some(Self::Online),
            "Degraded" => Some(Self::Degraded),
            "Offline" => Some(Self::Offline),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssetMetadataRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub asset_public_key: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssetMetadataResponse {
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub image: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub owner_commitment: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "6")]
    pub features: ::core::option::Option<OutputFeatures>,
    #[prost(uint64, tag = "7")]
    pub mined_height: u64,
    #[prost(bytes = "vec", tag = "8")]
    pub mined_in_block: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetRegistrationsRequest {
    #[prost(uint64, tag = "2")]
    pub offset: u64,
    #[prost(uint64, tag = "3")]
    pub count: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetRegistrationsResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub asset_public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub unique_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub owner_commitment: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub mined_height: u64,
    #[prost(bytes = "vec", tag = "5")]
    pub mined_in_block: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "6")]
    pub features: ::core::option::Option<OutputFeatures>,
    #[prost(bytes = "vec", tag = "7")]
    pub script: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTokensRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub asset_public_key: ::prost::alloc::vec::Vec<u8>,
    /// Optionally get a set of specific unique_ids
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub unique_ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTokensResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub unique_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub asset_public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub owner_commitment: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub mined_in_block: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "5")]
    pub mined_height: u64,
    #[prost(message, optional, tag = "6")]
    pub features: ::core::option::Option<OutputFeatures>,
    #[prost(bytes = "vec", tag = "7")]
    pub script: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitBlockResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub block_hash: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockBlobRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub header_blob: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub body_blob: ::prost::alloc::vec::Vec<u8>,
}
/// / return type of GetTipInfo
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TipInfoResponse {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<MetaData>,
    #[prost(bool, tag = "2")]
    pub initial_sync_achieved: bool,
    #[prost(enumeration = "BaseNodeState", tag = "3")]
    pub base_node_state: i32,
    #[prost(bool, tag = "4")]
    pub failed_checkpoints: bool,
}
/// / return type of GetNewBlockTemplate
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewBlockTemplateResponse {
    #[prost(message, optional, tag = "1")]
    pub new_block_template: ::core::option::Option<NewBlockTemplate>,
    #[prost(bool, tag = "3")]
    pub initial_sync_achieved: bool,
    #[prost(message, optional, tag = "4")]
    pub miner_data: ::core::option::Option<MinerData>,
}
/// / return type of NewBlockTemplateRequest
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewBlockTemplateRequest {
    #[prost(message, optional, tag = "1")]
    pub algo: ::core::option::Option<PowAlgo>,
    /// This field should be moved to optional once optional keyword is standard
    #[prost(uint64, tag = "2")]
    pub max_weight: u64,
}
/// / return type of NewBlockTemplateRequest
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNewBlockTemplateWithCoinbasesRequest {
    #[prost(message, optional, tag = "1")]
    pub algo: ::core::option::Option<PowAlgo>,
    /// This field should be moved to optional once optional keyword is standard
    #[prost(uint64, tag = "2")]
    pub max_weight: u64,
    #[prost(message, repeated, tag = "3")]
    pub coinbases: ::prost::alloc::vec::Vec<NewBlockCoinbase>,
}
/// / request  type of GetNewBlockWithCoinbasesRequest
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNewBlockWithCoinbasesRequest {
    #[prost(message, optional, tag = "1")]
    pub new_template: ::core::option::Option<NewBlockTemplate>,
    #[prost(message, repeated, tag = "2")]
    pub coinbases: ::prost::alloc::vec::Vec<NewBlockCoinbase>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewBlockCoinbase {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub value: u64,
    #[prost(bool, tag = "3")]
    pub stealth_payment: bool,
    #[prost(bool, tag = "4")]
    pub revealed_value_proof: bool,
    #[prost(bytes = "vec", tag = "5")]
    pub coinbase_extra: ::prost::alloc::vec::Vec<u8>,
}
/// Network difficulty response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkDifficultyResponse {
    #[prost(uint64, tag = "1")]
    pub difficulty: u64,
    #[prost(uint64, tag = "2")]
    pub estimated_hash_rate: u64,
    #[prost(uint64, tag = "3")]
    pub height: u64,
    #[prost(uint64, tag = "4")]
    pub timestamp: u64,
    #[prost(uint64, tag = "5")]
    pub pow_algo: u64,
    #[prost(uint64, tag = "6")]
    pub sha3x_estimated_hash_rate: u64,
    #[prost(uint64, tag = "7")]
    pub monero_randomx_estimated_hash_rate: u64,
    #[prost(uint64, tag = "10")]
    pub tari_randomx_estimated_hash_rate: u64,
    #[prost(uint64, tag = "8")]
    pub num_coinbases: u64,
    #[prost(bytes = "vec", repeated, tag = "9")]
    pub coinbase_extras: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// A generic single value response for a specific height
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueAtHeightResponse {
    /// uint64 circulating_supply = 1;    // No longer used
    /// uint64 spendable_supply = 2;      // No longer used
    #[prost(uint64, tag = "3")]
    pub height: u64,
    #[prost(uint64, tag = "4")]
    pub mined_rewards: u64,
    #[prost(uint64, tag = "5")]
    pub spendable_rewards: u64,
    #[prost(uint64, tag = "6")]
    pub spendable_pre_mine: u64,
    #[prost(uint64, tag = "7")]
    pub total_spendable: u64,
}
/// A generic uint value
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntegerValue {
    #[prost(uint64, tag = "1")]
    pub value: u64,
}
/// A generic String value
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringValue {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
/// / GetBlockSize / GetBlockFees Request
/// / Either the starting and ending heights OR the from_tip param must be specified
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockGroupRequest {
    /// The height from the chain tip (optional)
    #[prost(uint64, tag = "1")]
    pub from_tip: u64,
    /// The starting height (optional)
    #[prost(uint64, tag = "2")]
    pub start_height: u64,
    /// The ending height (optional)
    #[prost(uint64, tag = "3")]
    pub end_height: u64,
    /// / The type of calculation required (optional)
    /// / Defaults to median
    /// / median, mean, quartile, quantile
    #[prost(enumeration = "CalcType", tag = "4")]
    pub calc_type: i32,
}
/// / GetBlockSize / GetBlockFees  Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockGroupResponse {
    #[prost(double, repeated, tag = "1")]
    pub value: ::prost::alloc::vec::Vec<f64>,
    #[prost(enumeration = "CalcType", tag = "2")]
    pub calc_type: i32,
}
/// The request used for querying a function that requires a height, either between 2 points or from the chain tip
/// If start_height and end_height are set and > 0, they take precedence, otherwise from_tip is used
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeightRequest {
    /// The height from the chain tip (optional)
    #[prost(uint64, tag = "1")]
    pub from_tip: u64,
    /// The starting height (optional)
    #[prost(uint64, tag = "2")]
    pub start_height: u64,
    /// The ending height (optional)
    #[prost(uint64, tag = "3")]
    pub end_height: u64,
}
/// The return type of the rpc GetBlockTiming
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockTimingResponse {
    #[prost(uint64, tag = "1")]
    pub max: u64,
    #[prost(uint64, tag = "2")]
    pub min: u64,
    #[prost(double, tag = "3")]
    pub avg: f64,
}
/// Request that returns a header based by hash
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHeaderByHashRequest {
    /// The hash of the block header
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHeaderResponse {
    /// The block header
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<BlockHeader>,
    /// The number of blocks from the tip of this block (a.k.a depth)
    #[prost(uint64, tag = "2")]
    pub confirmations: u64,
    /// The block reward i.e mining reward + fees
    #[prost(uint64, tag = "3")]
    pub reward: u64,
    /// Achieved difficulty
    #[prost(uint64, tag = "4")]
    pub difficulty: u64,
    /// The number of transactions contained in the block
    #[prost(uint32, tag = "5")]
    pub num_transactions: u32,
}
/// The request used for querying headers from the base node. The parameters `from_height` and `num_headers` can be used
/// to page through the current best chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHeadersRequest {
    /// The height to start at. Depending on sorting, will either default to use the tip or genesis block, for `SORTING_DESC`
    /// and `SORTING_ASC` respectively, if a value is not provided. The first header returned will be at this height
    /// followed by `num_headers` - 1 headers in the direction specified by `sorting`. If greater than the current tip,
    /// the current tip will be used.
    #[prost(uint64, tag = "1")]
    pub from_height: u64,
    /// The number of headers to return. If not specified, it will default to 10
    #[prost(uint64, tag = "2")]
    pub num_headers: u64,
    /// The ordering to return the headers in. If not specified will default to SORTING_DESC. Note that if `from_height`
    /// is not specified or is 0, if `sorting` is SORTING_DESC, the tip will be used as `from_height`, otherwise the
    /// block at height 0 will be used.
    #[prost(enumeration = "Sorting", tag = "3")]
    pub sorting: i32,
}
/// The request used for querying blocks in the base node's current best chain. Currently only querying by height is
/// available. Multiple blocks may be queried.e.g. \[189092,100023,122424\]. The order in which they are returned is not
/// guaranteed.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlocksRequest {
    #[prost(uint64, repeated, tag = "1")]
    pub heights: ::prost::alloc::vec::Vec<u64>,
}
/// The return type of the rpc GetBlocks. Blocks are not guaranteed to be returned in the order requested.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlocksResponse {
    #[prost(message, repeated, tag = "1")]
    pub blocks: ::prost::alloc::vec::Vec<HistoricalBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaData {
    /// The current chain height, or the block number of the longest valid chain, or `None` if there is no chain
    #[prost(uint64, tag = "1")]
    pub best_block_height: u64,
    /// The block hash of the current tip of the longest valid chain, or `None` for an empty chain
    #[prost(bytes = "vec", tag = "2")]
    pub best_block_hash: ::prost::alloc::vec::Vec<u8>,
    /// The current geometric mean of the pow of the chain tip, or `None` if there is no chain
    #[prost(bytes = "vec", tag = "5")]
    pub accumulated_difficulty: ::prost::alloc::vec::Vec<u8>,
    /// This is the min height this node can provide complete blocks for. A 0 here means this node is archival and can provide complete blocks for every height.
    #[prost(uint64, tag = "6")]
    pub pruned_height: u64,
    #[prost(uint64, tag = "7")]
    pub timestamp: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncInfoResponse {
    #[prost(uint64, tag = "1")]
    pub tip_height: u64,
    #[prost(uint64, tag = "2")]
    pub local_height: u64,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub peer_node_id: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncProgressResponse {
    #[prost(uint64, tag = "1")]
    pub tip_height: u64,
    #[prost(uint64, tag = "2")]
    pub local_height: u64,
    #[prost(enumeration = "SyncState", tag = "3")]
    pub state: i32,
    #[prost(string, tag = "4")]
    pub short_desc: ::prost::alloc::string::String,
    #[prost(uint64, tag = "5")]
    pub initial_connected_peers: u64,
}
/// This is the message that is returned for a miner after it asks for a new block.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNewBlockResult {
    /// This is the header hash of the completed block
    #[prost(bytes = "vec", tag = "1")]
    pub block_hash: ::prost::alloc::vec::Vec<u8>,
    /// This is the completed block
    #[prost(message, optional, tag = "2")]
    pub block: ::core::option::Option<Block>,
    #[prost(bytes = "vec", tag = "3")]
    pub merge_mining_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub tari_unique_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub miner_data: ::core::option::Option<MinerData>,
    #[prost(bytes = "vec", tag = "6")]
    pub vm_key: ::prost::alloc::vec::Vec<u8>,
}
/// This is the message that is returned for a miner after it asks for a new block.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNewBlockBlobResult {
    /// This is the header hash of the completed block
    #[prost(bytes = "vec", tag = "1")]
    pub block_hash: ::prost::alloc::vec::Vec<u8>,
    /// This is the completed block's header
    #[prost(bytes = "vec", tag = "2")]
    pub header: ::prost::alloc::vec::Vec<u8>,
    /// This is the completed block's body
    #[prost(bytes = "vec", tag = "3")]
    pub block_body: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub merge_mining_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub utxo_mr: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub tari_unique_id: ::prost::alloc::vec::Vec<u8>,
}
/// This is mining data for the miner asking for a new block
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MinerData {
    #[prost(message, optional, tag = "1")]
    pub algo: ::core::option::Option<PowAlgo>,
    #[prost(uint64, tag = "2")]
    pub target_difficulty: u64,
    #[prost(uint64, tag = "3")]
    pub reward: u64,
    ///     bytes merge_mining_hash =4;
    #[prost(uint64, tag = "5")]
    pub total_fees: u64,
}
/// This is the request type for the Search Kernels rpc
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchKernelsRequest {
    #[prost(message, repeated, tag = "1")]
    pub signatures: ::prost::alloc::vec::Vec<Signature>,
}
/// This is the request type for the Search Utxo rpc
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchUtxosRequest {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub commitments: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchMatchingUtxosRequest {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub hashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchMatchingUtxosResponse {
    #[prost(message, optional, tag = "1")]
    pub output: ::core::option::Option<TransactionOutput>,
}
/// This is the request type of the get all peers rpc call
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPeersResponse {
    #[prost(message, optional, tag = "1")]
    pub peer: ::core::option::Option<Peer>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPeersRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTransactionRequest {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTransactionResponse {
    #[prost(enumeration = "SubmitTransactionResult", tag = "1")]
    pub result: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMempoolTransactionsRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMempoolTransactionsResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<Transaction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionStateRequest {
    #[prost(message, optional, tag = "1")]
    pub excess_sig: ::core::option::Option<Signature>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionStateResponse {
    #[prost(enumeration = "TransactionLocation", tag = "1")]
    pub result: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MempoolStatsResponse {
    #[prost(uint64, tag = "2")]
    pub unconfirmed_txs: u64,
    #[prost(uint64, tag = "3")]
    pub reorg_txs: u64,
    #[prost(uint64, tag = "4")]
    pub unconfirmed_weight: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActiveValidatorNodesRequest {
    #[prost(uint64, tag = "1")]
    pub height: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetActiveValidatorNodesResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub shard_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShardKeyRequest {
    #[prost(uint64, tag = "1")]
    pub height: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShardKeyResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub shard_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "2")]
    pub found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTemplateRegistrationsRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub start_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub count: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTemplateRegistrationResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub utxo_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub registration: ::core::option::Option<TemplateRegistration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockInfo {
    #[prost(uint64, tag = "1")]
    pub height: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub next_block_hash: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSideChainUtxosRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub start_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub count: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSideChainUtxosResponse {
    #[prost(message, optional, tag = "1")]
    pub block_info: ::core::option::Option<BlockInfo>,
    #[prost(message, repeated, tag = "2")]
    pub outputs: ::prost::alloc::vec::Vec<TransactionOutput>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkStateRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkStateResponse {
    /// metadata
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<MetaData>,
    /// has the base node synced
    #[prost(bool, tag = "2")]
    pub initial_sync_achieved: bool,
    /// current state of the base node
    #[prost(enumeration = "BaseNodeState", tag = "3")]
    pub base_node_state: i32,
    /// do we have failed checkpoints
    #[prost(bool, tag = "4")]
    pub failed_checkpoints: bool,
    /// The block reward of the next tip
    #[prost(uint64, tag = "5")]
    pub reward: u64,
    /// estimate sha3x hash rate
    #[prost(uint64, tag = "6")]
    pub sha3x_estimated_hash_rate: u64,
    /// estimate randomx hash rate
    #[prost(uint64, tag = "7")]
    pub monero_randomx_estimated_hash_rate: u64,
    #[prost(uint64, tag = "10")]
    pub tari_randomx_estimated_hash_rate: u64,
    /// number of connections
    #[prost(uint64, tag = "8")]
    pub num_connections: u64,
    /// liveness results
    #[prost(message, repeated, tag = "9")]
    pub liveness_results: ::prost::alloc::vec::Vec<LivenessResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LivenessResult {
    /// node id
    #[prost(bytes = "vec", tag = "1")]
    pub peer_node_id: ::prost::alloc::vec::Vec<u8>,
    /// time to discover
    #[prost(uint64, tag = "2")]
    pub discover_latency: u64,
    /// Dial latency
    #[prost(uint64, tag = "3")]
    pub ping_latency: u64,
}
/// Request to search for outputs by payment reference
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchPaymentReferencesRequest {
    /// Payment reference as hex string (64 characters)
    #[prost(string, repeated, tag = "1")]
    pub payment_reference_hex: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub payment_reference_bytes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Optional: include spent outputs in results
    #[prost(bool, tag = "3")]
    pub include_spent: bool,
}
/// Response containing payment reference match
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentReferenceResponse {
    /// The payment reference that was found
    #[prost(string, tag = "1")]
    pub payment_reference_hex: ::prost::alloc::string::String,
    /// Block height where the output was mined
    #[prost(uint64, tag = "2")]
    pub block_height: u64,
    /// Block hash where the output was mined
    #[prost(bytes = "vec", tag = "3")]
    pub block_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the output was mined
    #[prost(uint64, tag = "4")]
    pub mined_timestamp: u64,
    /// Output commitment (32 bytes)
    #[prost(bytes = "vec", tag = "5")]
    pub commitment: ::prost::alloc::vec::Vec<u8>,
    /// Whether this output has been spent
    #[prost(bool, tag = "6")]
    pub is_spent: bool,
    /// Height where output was spent (if spent)
    #[prost(uint64, tag = "7")]
    pub spent_height: u64,
    /// Block hash where output was spent (if spent)
    #[prost(bytes = "vec", tag = "8")]
    pub spent_block_hash: ::prost::alloc::vec::Vec<u8>,
    /// Transaction output amount will be 0 for non set a
    #[prost(uint64, tag = "9")]
    pub min_value_promise: u64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BaseNodeState {
    StartUp = 0,
    HeaderSync = 1,
    HorizonSync = 2,
    Connecting = 3,
    BlockSync = 4,
    Listening = 5,
    SyncFailed = 6,
}
impl BaseNodeState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BaseNodeState::StartUp => "START_UP",
            BaseNodeState::HeaderSync => "HEADER_SYNC",
            BaseNodeState::HorizonSync => "HORIZON_SYNC",
            BaseNodeState::Connecting => "CONNECTING",
            BaseNodeState::BlockSync => "BLOCK_SYNC",
            BaseNodeState::Listening => "LISTENING",
            BaseNodeState::SyncFailed => "SYNC_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "START_UP" => Some(Self::StartUp),
            "HEADER_SYNC" => Some(Self::HeaderSync),
            "HORIZON_SYNC" => Some(Self::HorizonSync),
            "CONNECTING" => Some(Self::Connecting),
            "BLOCK_SYNC" => Some(Self::BlockSync),
            "LISTENING" => Some(Self::Listening),
            "SYNC_FAILED" => Some(Self::SyncFailed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CalcType {
    Mean = 0,
    Median = 1,
    Quantile = 2,
    Quartile = 3,
}
impl CalcType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CalcType::Mean => "MEAN",
            CalcType::Median => "MEDIAN",
            CalcType::Quantile => "QUANTILE",
            CalcType::Quartile => "QUARTILE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MEAN" => Some(Self::Mean),
            "MEDIAN" => Some(Self::Median),
            "QUANTILE" => Some(Self::Quantile),
            "QUARTILE" => Some(Self::Quartile),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Sorting {
    Desc = 0,
    Asc = 1,
}
impl Sorting {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Sorting::Desc => "SORTING_DESC",
            Sorting::Asc => "SORTING_ASC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SORTING_DESC" => Some(Self::Desc),
            "SORTING_ASC" => Some(Self::Asc),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SyncState {
    Startup = 0,
    HeaderStarting = 1,
    Header = 2,
    BlockStarting = 3,
    Block = 4,
    Done = 5,
}
impl SyncState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SyncState::Startup => "STARTUP",
            SyncState::HeaderStarting => "HEADER_STARTING",
            SyncState::Header => "HEADER",
            SyncState::BlockStarting => "BLOCK_STARTING",
            SyncState::Block => "BLOCK",
            SyncState::Done => "DONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STARTUP" => Some(Self::Startup),
            "HEADER_STARTING" => Some(Self::HeaderStarting),
            "HEADER" => Some(Self::Header),
            "BLOCK_STARTING" => Some(Self::BlockStarting),
            "BLOCK" => Some(Self::Block),
            "DONE" => Some(Self::Done),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubmitTransactionResult {
    None = 0,
    Accepted = 1,
    NotProcessableAtThisTime = 2,
    AlreadyMined = 3,
    Rejected = 4,
}
impl SubmitTransactionResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SubmitTransactionResult::None => "NONE",
            SubmitTransactionResult::Accepted => "ACCEPTED",
            SubmitTransactionResult::NotProcessableAtThisTime => {
                "NOT_PROCESSABLE_AT_THIS_TIME"
            }
            SubmitTransactionResult::AlreadyMined => "ALREADY_MINED",
            SubmitTransactionResult::Rejected => "REJECTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "ACCEPTED" => Some(Self::Accepted),
            "NOT_PROCESSABLE_AT_THIS_TIME" => Some(Self::NotProcessableAtThisTime),
            "ALREADY_MINED" => Some(Self::AlreadyMined),
            "REJECTED" => Some(Self::Rejected),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionLocation {
    Unknown = 0,
    Mempool = 1,
    Mined = 2,
    NotStored = 3,
}
impl TransactionLocation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TransactionLocation::Unknown => "UNKNOWN",
            TransactionLocation::Mempool => "MEMPOOL",
            TransactionLocation::Mined => "MINED",
            TransactionLocation::NotStored => "NOT_STORED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "MEMPOOL" => Some(Self::Mempool),
            "MINED" => Some(Self::Mined),
            "NOT_STORED" => Some(Self::NotStored),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod base_node_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The gRPC interface for interacting with the base node.
    #[derive(Debug, Clone)]
    pub struct BaseNodeClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BaseNodeClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BaseNodeClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BaseNodeClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            BaseNodeClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists headers in the current best chain
        pub async fn list_headers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHeadersRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::BlockHeaderResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/ListHeaders",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "ListHeaders"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Get header by hash
        pub async fn get_header_by_hash(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHeaderByHashRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BlockHeaderResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetHeaderByHash",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetHeaderByHash"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns blocks in the current best chain. Currently only supports querying by height
        pub async fn get_blocks(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBlocksRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HistoricalBlock>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetBlocks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetBlocks"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Returns the block timing for the chain heights
        pub async fn get_block_timing(
            &mut self,
            request: impl tonic::IntoRequest<super::HeightRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BlockTimingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetBlockTiming",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetBlockTiming"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the network Constants
        pub async fn get_constants(
            &mut self,
            request: impl tonic::IntoRequest<super::BlockHeight>,
        ) -> std::result::Result<
            tonic::Response<super::ConsensusConstants>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetConstants",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetConstants"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns Block Sizes
        pub async fn get_block_size(
            &mut self,
            request: impl tonic::IntoRequest<super::BlockGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BlockGroupResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetBlockSize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetBlockSize"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns Block Fees
        pub async fn get_block_fees(
            &mut self,
            request: impl tonic::IntoRequest<super::BlockGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BlockGroupResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetBlockFees",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetBlockFees"));
            self.inner.unary(req, path, codec).await
        }
        /// Get Version
        pub async fn get_version(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<tonic::Response<super::StringValue>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetVersion"));
            self.inner.unary(req, path, codec).await
        }
        /// Check for new updates
        pub async fn check_for_updates(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<tonic::Response<super::SoftwareUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/CheckForUpdates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "CheckForUpdates"));
            self.inner.unary(req, path, codec).await
        }
        /// Get coins in circulation
        pub async fn get_tokens_in_circulation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBlocksRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ValueAtHeightResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetTokensInCirculation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetTokensInCirculation"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Get network difficulties
        pub async fn get_network_difficulty(
            &mut self,
            request: impl tonic::IntoRequest<super::HeightRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::NetworkDifficultyResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetNetworkDifficulty",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetNetworkDifficulty"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Get the block template
        pub async fn get_new_block_template(
            &mut self,
            request: impl tonic::IntoRequest<super::NewBlockTemplateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NewBlockTemplateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetNewBlockTemplate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetNewBlockTemplate"));
            self.inner.unary(req, path, codec).await
        }
        /// Construct a new block from a provided template
        pub async fn get_new_block(
            &mut self,
            request: impl tonic::IntoRequest<super::NewBlockTemplate>,
        ) -> std::result::Result<
            tonic::Response<super::GetNewBlockResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetNewBlock",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetNewBlock"));
            self.inner.unary(req, path, codec).await
        }
        /// Construct a new block from a provided template
        pub async fn get_new_block_with_coinbases(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNewBlockWithCoinbasesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNewBlockResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetNewBlockWithCoinbases",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tari.rpc.BaseNode", "GetNewBlockWithCoinbases"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Construct a new block from a provided template
        pub async fn get_new_block_template_with_coinbases(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetNewBlockTemplateWithCoinbasesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::GetNewBlockResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetNewBlockTemplateWithCoinbases",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tari.rpc.BaseNode",
                        "GetNewBlockTemplateWithCoinbases",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Construct a new block and header blob from a provided template
        pub async fn get_new_block_blob(
            &mut self,
            request: impl tonic::IntoRequest<super::NewBlockTemplate>,
        ) -> std::result::Result<
            tonic::Response<super::GetNewBlockBlobResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetNewBlockBlob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetNewBlockBlob"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit a new block for propagation
        pub async fn submit_block(
            &mut self,
            request: impl tonic::IntoRequest<super::Block>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitBlockResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/SubmitBlock",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "SubmitBlock"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit a new mined block blob for propagation
        pub async fn submit_block_blob(
            &mut self,
            request: impl tonic::IntoRequest<super::BlockBlobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitBlockResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/SubmitBlockBlob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "SubmitBlockBlob"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit a transaction for propagation
        pub async fn submit_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/SubmitTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "SubmitTransaction"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the base node sync information
        pub async fn get_sync_info(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::SyncInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetSyncInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetSyncInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the base node sync information
        pub async fn get_sync_progress(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::SyncProgressResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetSyncProgress",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetSyncProgress"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the base node tip information
        pub async fn get_tip_info(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::TipInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetTipInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetTipInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// Search for blocks containing the specified kernels
        pub async fn search_kernels(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchKernelsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HistoricalBlock>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/SearchKernels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "SearchKernels"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Search for blocks containing the specified commitments
        pub async fn search_utxos(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchUtxosRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HistoricalBlock>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/SearchUtxos",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "SearchUtxos"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Fetch any utxos that exist in the main chain
        pub async fn fetch_matching_utxos(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchMatchingUtxosRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::FetchMatchingUtxosResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/FetchMatchingUtxos",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "FetchMatchingUtxos"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// get all peers from the base node
        pub async fn get_peers(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPeersRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetPeersResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetPeers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetPeers"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_mempool_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMempoolTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::GetMempoolTransactionsResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetMempoolTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetMempoolTransactions"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn transaction_state(
            &mut self,
            request: impl tonic::IntoRequest<super::TransactionStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TransactionStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/TransactionState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "TransactionState"));
            self.inner.unary(req, path, codec).await
        }
        /// This returns the node's network identity
        pub async fn identify(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<tonic::Response<super::NodeIdentity>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/Identify",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "Identify"));
            self.inner.unary(req, path, codec).await
        }
        /// Get Base Node network connectivity status
        pub async fn get_network_status(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetNetworkStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetNetworkStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// List currently connected peers
        pub async fn list_connected_peers(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::ListConnectedPeersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/ListConnectedPeers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "ListConnectedPeers"));
            self.inner.unary(req, path, codec).await
        }
        /// Get mempool stats
        pub async fn get_mempool_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::MempoolStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetMempoolStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetMempoolStats"));
            self.inner.unary(req, path, codec).await
        }
        /// Get VNs
        pub async fn get_active_validator_nodes(
            &mut self,
            request: impl tonic::IntoRequest<super::GetActiveValidatorNodesRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::GetActiveValidatorNodesResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetActiveValidatorNodes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetActiveValidatorNodes"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_shard_key(
            &mut self,
            request: impl tonic::IntoRequest<super::GetShardKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetShardKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetShardKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetShardKey"));
            self.inner.unary(req, path, codec).await
        }
        /// Get templates
        pub async fn get_template_registrations(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTemplateRegistrationsRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::GetTemplateRegistrationResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetTemplateRegistrations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tari.rpc.BaseNode", "GetTemplateRegistrations"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_side_chain_utxos(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSideChainUtxosRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetSideChainUtxosResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetSideChainUtxos",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetSideChainUtxos"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_network_state(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNetworkStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNetworkStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/GetNetworkState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "GetNetworkState"));
            self.inner.unary(req, path, codec).await
        }
        /// PayRef (Payment Reference) lookup for block explorers and external services
        pub async fn search_payment_references(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchPaymentReferencesRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PaymentReferenceResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.BaseNode/SearchPaymentReferences",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.BaseNode", "SearchPaymentReferences"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTipInfoRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTipInfoResponse {
    #[prost(uint64, tag = "1")]
    pub node_height: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub node_tip_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "3")]
    pub p2pool_rx_height: u64,
    #[prost(bytes = "vec", tag = "4")]
    pub p2pool_rx_tip_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "5")]
    pub p2pool_sha_height: u64,
    #[prost(bytes = "vec", tag = "6")]
    pub p2pool_sha_tip_hash: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNewBlockRequest {
    #[prost(message, optional, tag = "1")]
    pub pow: ::core::option::Option<PowAlgo>,
    #[prost(string, tag = "2")]
    pub coinbase_extra: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub wallet_payment_address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNewBlockResponse {
    #[prost(message, optional, tag = "1")]
    pub block: ::core::option::Option<GetNewBlockResult>,
    #[prost(uint64, tag = "2")]
    pub target_difficulty: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitBlockRequest {
    #[prost(message, optional, tag = "1")]
    pub block: ::core::option::Option<Block>,
    #[prost(string, tag = "2")]
    pub wallet_payment_address: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod sha_p2_pool_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ShaP2PoolClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ShaP2PoolClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ShaP2PoolClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ShaP2PoolClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ShaP2PoolClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_tip_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTipInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTipInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.ShaP2Pool/GetTipInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.ShaP2Pool", "GetTipInfo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_new_block(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNewBlockRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNewBlockResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.ShaP2Pool/GetNewBlock",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.ShaP2Pool", "GetNewBlock"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_block(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitBlockRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitBlockResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.ShaP2Pool/SubmitBlock",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.ShaP2Pool", "SubmitBlock"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// empty
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConstitutionRequestsRequest {}
/// empty
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetadataRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishContractAcceptanceRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub contract_id: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishContractAcceptanceResponse {
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub tx_id: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishContractUpdateProposalAcceptanceRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub contract_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub proposal_id: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishContractUpdateProposalAcceptanceResponse {
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub tx_id: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetadataResponse {
    #[prost(message, repeated, tag = "1")]
    pub sidechains: ::prost::alloc::vec::Vec<SidechainMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SidechainMetadata {
    #[prost(bytes = "vec", tag = "1")]
    pub asset_public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub committed_height: u64,
    #[prost(bytes = "vec", tag = "3")]
    pub committed_hash: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTokenDataRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub asset_pub_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub unique_id: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTokenDataResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeReadMethodRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub contract_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub template_id: u32,
    #[prost(string, tag = "3")]
    pub method: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub args: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeReadMethodResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub result: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub authority: ::core::option::Option<Authority>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Authority {
    #[prost(bytes = "vec", tag = "1")]
    pub node_public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub proxied_by: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeMethodRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub contract_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub template_id: u32,
    #[prost(string, tag = "3")]
    pub method: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub args: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeMethodResponse {
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub result: ::prost::alloc::vec::Vec<u8>,
}
/// Generated client implementations.
pub mod validator_node_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ValidatorNodeClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ValidatorNodeClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ValidatorNodeClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ValidatorNodeClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ValidatorNodeClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_identity(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIdentityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetIdentityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.ValidatorNode/GetIdentity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.ValidatorNode", "GetIdentity"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.ValidatorNode/GetMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.ValidatorNode", "GetMetadata"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_token_data(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTokenDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTokenDataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.ValidatorNode/GetTokenData",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.ValidatorNode", "GetTokenData"));
            self.inner.unary(req, path, codec).await
        }
        ///    rpc ExecuteInstruction(ExecuteInstructionRequest) returns (ExecuteInstructionResponse);
        pub async fn invoke_read_method(
            &mut self,
            request: impl tonic::IntoRequest<super::InvokeReadMethodRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InvokeReadMethodResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.ValidatorNode/InvokeReadMethod",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.ValidatorNode", "InvokeReadMethod"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn invoke_method(
            &mut self,
            request: impl tonic::IntoRequest<super::InvokeMethodRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InvokeMethodResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.ValidatorNode/InvokeMethod",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.ValidatorNode", "InvokeMethod"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_constitution_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConstitutionRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TransactionOutput>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.ValidatorNode/GetConstitutionRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tari.rpc.ValidatorNode", "GetConstitutionRequests"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn publish_contract_acceptance(
            &mut self,
            request: impl tonic::IntoRequest<super::PublishContractAcceptanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PublishContractAcceptanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.ValidatorNode/PublishContractAcceptance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tari.rpc.ValidatorNode",
                        "PublishContractAcceptance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn publish_contract_update_proposal_acceptance(
            &mut self,
            request: impl tonic::IntoRequest<
                super::PublishContractUpdateProposalAcceptanceRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::PublishContractUpdateProposalAcceptanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.ValidatorNode/PublishContractUpdateProposalAcceptance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tari.rpc.ValidatorNode",
                        "PublishContractUpdateProposalAcceptance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVersionRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVersionResponse {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAddressResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub interactive_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub one_sided_address: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPaymentIdAddressRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub payment_id: ::prost::alloc::vec::Vec<u8>,
}
/// Response message containing all formats of wallet addresses.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCompleteAddressResponse {
    /// Binary form of the interactive address.
    #[prost(bytes = "vec", tag = "1")]
    pub interactive_address: ::prost::alloc::vec::Vec<u8>,
    /// Binary form of the one-sided address.
    #[prost(bytes = "vec", tag = "2")]
    pub one_sided_address: ::prost::alloc::vec::Vec<u8>,
    /// Base58-encoded version of the interactive address.
    #[prost(string, tag = "3")]
    pub interactive_address_base58: ::prost::alloc::string::String,
    /// Base58-encoded version of the one-sided address.
    #[prost(string, tag = "4")]
    pub one_sided_address_base58: ::prost::alloc::string::String,
    /// Emoji-encoded version of the interactive address.
    #[prost(string, tag = "5")]
    pub interactive_address_emoji: ::prost::alloc::string::String,
    /// Emoji-encoded version of the one-sided address.
    #[prost(string, tag = "6")]
    pub one_sided_address_emoji: ::prost::alloc::string::String,
}
/// A request to send funds to one or more recipients.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferRequest {
    #[prost(message, repeated, tag = "1")]
    pub recipients: ::prost::alloc::vec::Vec<PaymentRecipient>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendShaAtomicSwapRequest {
    #[prost(message, optional, tag = "1")]
    pub recipient: ::core::option::Option<PaymentRecipient>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBurnTransactionRequest {
    #[prost(uint64, tag = "1")]
    pub amount: u64,
    #[prost(uint64, tag = "2")]
    pub fee_per_gram: u64,
    #[prost(bytes = "vec", tag = "4")]
    pub claim_public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub payment_id: ::prost::alloc::vec::Vec<u8>,
}
/// A recipient for a transfer, including address, amount, fee, and optional payment ID.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentRecipient {
    /// Base58 Tari address of the recipient.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// Amount to send in microTari (1 T = 1_000_000 µT).
    #[prost(uint64, tag = "2")]
    pub amount: u64,
    /// Fee rate per gram.
    #[prost(uint64, tag = "3")]
    pub fee_per_gram: u64,
    /// The type of payment to perform.
    #[prost(enumeration = "payment_recipient::PaymentType", tag = "5")]
    pub payment_type: i32,
    /// raw payment id
    #[prost(bytes = "vec", tag = "6")]
    pub raw_payment_id: ::prost::alloc::vec::Vec<u8>,
    /// Optional user encrypted payment ID for reference (max 256 bytes).
    #[prost(message, optional, tag = "7")]
    pub user_payment_id: ::core::option::Option<UserPaymentId>,
}
/// Nested message and enum types in `PaymentRecipient`.
pub mod payment_recipient {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PaymentType {
        /// Default Mimblewimble-style transaction.
        StandardMimblewimble = 0,
        /// One-sided transaction (receiver not required to participate).
        OneSided = 1,
        /// One-sided stealth address (adds privacy by hiding destination).
        OneSidedToStealthAddress = 2,
    }
    impl PaymentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PaymentType::StandardMimblewimble => "STANDARD_MIMBLEWIMBLE",
                PaymentType::OneSided => "ONE_SIDED",
                PaymentType::OneSidedToStealthAddress => "ONE_SIDED_TO_STEALTH_ADDRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STANDARD_MIMBLEWIMBLE" => Some(Self::StandardMimblewimble),
                "ONE_SIDED" => Some(Self::OneSided),
                "ONE_SIDED_TO_STEALTH_ADDRESS" => Some(Self::OneSidedToStealthAddress),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<TransferResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendShaAtomicSwapResponse {
    #[prost(uint64, tag = "1")]
    pub transaction_id: u64,
    #[prost(string, tag = "2")]
    pub pre_image: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub output_hash: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub is_success: bool,
    #[prost(string, tag = "5")]
    pub failure_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBurnTransactionResponse {
    #[prost(uint64, tag = "1")]
    pub transaction_id: u64,
    #[prost(bool, tag = "2")]
    pub is_success: bool,
    #[prost(string, tag = "3")]
    pub failure_message: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub commitment: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub ownership_proof: ::core::option::Option<CommitmentSignature>,
    #[prost(bytes = "vec", tag = "6")]
    pub range_proof: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "7")]
    pub reciprocal_claim_public_key: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferResult {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub transaction_id: u64,
    #[prost(bool, tag = "3")]
    pub is_success: bool,
    #[prost(string, tag = "4")]
    pub failure_message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub transaction_info: ::core::option::Option<TransactionInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimShaAtomicSwapRequest {
    #[prost(string, tag = "1")]
    pub output: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pre_image: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub fee_per_gram: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimShaAtomicSwapResponse {
    #[prost(message, optional, tag = "1")]
    pub results: ::core::option::Option<TransferResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimHtlcRefundRequest {
    #[prost(string, tag = "1")]
    pub output_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub fee_per_gram: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimHtlcRefundResponse {
    #[prost(message, optional, tag = "1")]
    pub results: ::core::option::Option<TransferResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionInfoRequest {
    #[prost(uint64, repeated, tag = "1")]
    pub transaction_ids: ::prost::alloc::vec::Vec<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionInfoResponse {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<TransactionInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionInfo {
    #[prost(uint64, tag = "1")]
    pub tx_id: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub source_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub dest_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "TransactionStatus", tag = "4")]
    pub status: i32,
    #[prost(enumeration = "TransactionDirection", tag = "5")]
    pub direction: i32,
    #[prost(uint64, tag = "6")]
    pub amount: u64,
    #[prost(uint64, tag = "7")]
    pub fee: u64,
    #[prost(bool, tag = "8")]
    pub is_cancelled: bool,
    #[prost(bytes = "vec", tag = "9")]
    pub excess_sig: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "10")]
    pub timestamp: u64,
    #[prost(bytes = "vec", tag = "12")]
    pub raw_payment_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "13")]
    pub mined_in_block_height: u64,
    #[prost(bytes = "vec", tag = "14")]
    pub user_payment_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", repeated, tag = "15")]
    pub input_commitments: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "16")]
    pub output_commitments: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "17")]
    pub payment_references_sent: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "18")]
    pub payment_references_received: ::prost::alloc::vec::Vec<
        ::prost::alloc::vec::Vec<u8>,
    >,
    #[prost(bytes = "vec", repeated, tag = "19")]
    pub payment_references_change: ::prost::alloc::vec::Vec<
        ::prost::alloc::vec::Vec<u8>,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCompletedTransactionsRequest {
    #[prost(message, optional, tag = "1")]
    pub payment_id: ::core::option::Option<UserPaymentId>,
    #[prost(message, optional, tag = "2")]
    pub block_hash: ::core::option::Option<BlockHashHex>,
    #[prost(message, optional, tag = "3")]
    pub block_height: ::core::option::Option<BlockHeight>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockHashHex {
    #[prost(string, tag = "1")]
    pub hash: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCompletedTransactionsResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<TransactionInfo>,
}
/// Request message for GetBalance RPC.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {
    /// Optional: A user-defined payment ID to filter balance data.
    /// Must provide only one of the following fields: u256, utf8_string, or user_bytes.
    #[prost(message, optional, tag = "1")]
    pub payment_id: ::core::option::Option<UserPaymentId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserPaymentId {
    #[prost(bytes = "vec", tag = "1")]
    pub u256: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub utf8_string: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub user_bytes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    #[prost(uint64, tag = "1")]
    pub available_balance: u64,
    #[prost(uint64, tag = "2")]
    pub pending_incoming_balance: u64,
    #[prost(uint64, tag = "3")]
    pub pending_outgoing_balance: u64,
    #[prost(uint64, tag = "4")]
    pub timelocked_balance: u64,
}
/// Response message for GetState
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateResponse {
    /// The blockchain height (in blocks) that the wallet has scanned up to
    #[prost(uint64, tag = "1")]
    pub scanned_height: u64,
    /// Current wallet balance information (available, pending), based on the GetBalanceResponse
    #[prost(message, optional, tag = "2")]
    pub balance: ::core::option::Option<GetBalanceResponse>,
    /// Status of the wallet's connection to the base node, based on the NetworkStatusResponse
    #[prost(message, optional, tag = "3")]
    pub network: ::core::option::Option<NetworkStatusResponse>,
}
/// Response message for GetUnspentAmounts RPC.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUnspentAmountsResponse {
    /// Total value of all unspent outputs, in the smallest unit (e.g., microTari).
    #[prost(uint64, repeated, tag = "1")]
    pub amount: ::prost::alloc::vec::Vec<u64>,
}
/// Request message for the CoinSplit RPC.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinSplitRequest {
    /// The value of each output to create.
    #[prost(uint64, tag = "1")]
    pub amount_per_split: u64,
    /// The number of outputs to create in total.
    #[prost(uint64, tag = "2")]
    pub split_count: u64,
    /// Fee rate per weight unit (gram).
    #[prost(uint64, tag = "3")]
    pub fee_per_gram: u64,
    /// Block height when the transaction becomes valid.
    #[prost(uint64, tag = "5")]
    pub lock_height: u64,
    /// Optional identifier for referencing the transaction.
    #[prost(bytes = "vec", tag = "6")]
    pub payment_id: ::prost::alloc::vec::Vec<u8>,
}
/// Response message containing the transaction ID of the coin split.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoinSplitResponse {
    /// The unique ID of the transaction created.
    #[prost(uint64, tag = "1")]
    pub tx_id: u64,
}
/// Request message for importing UTXOs into the wallet.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportUtxosRequest {
    /// List of unblinded outputs to be imported as UTXOs.
    #[prost(message, repeated, tag = "1")]
    pub outputs: ::prost::alloc::vec::Vec<UnblindedOutput>,
    /// Optional payment ID to tag the imported outputs.
    #[prost(bytes = "vec", tag = "2")]
    pub payment_id: ::prost::alloc::vec::Vec<u8>,
}
/// Response message containing transaction IDs for the imported outputs.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportUtxosResponse {
    /// Transaction IDs corresponding to the imported UTXOs.
    #[prost(uint64, repeated, tag = "1")]
    pub tx_ids: ::prost::alloc::vec::Vec<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTemplateRegistrationRequest {
    #[prost(message, optional, tag = "1")]
    pub template_registration: ::core::option::Option<TemplateRegistration>,
    #[prost(uint64, tag = "2")]
    pub fee_per_gram: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTemplateRegistrationResponse {
    #[prost(uint64, tag = "1")]
    pub tx_id: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub template_address: ::prost::alloc::vec::Vec<u8>,
}
/// Request message for the CancelTransaction RPC.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTransactionRequest {
    /// The transaction ID to be cancelled.
    #[prost(uint64, tag = "1")]
    pub tx_id: u64,
}
/// Response message for the CancelTransaction RPC.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTransactionResponse {
    /// Indicates whether the cancellation was successful.
    #[prost(bool, tag = "1")]
    pub is_success: bool,
    /// The failure message if the cancellation was not successful.
    #[prost(string, tag = "2")]
    pub failure_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevalidateRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevalidateResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetBaseNodeRequest {
    #[prost(string, tag = "1")]
    pub public_key_hex: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub net_address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetBaseNodeResponse {}
/// Empty request for CheckConnectivity
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectivityRequest {}
/// Response indicating the wallet's connectivity status
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckConnectivityResponse {
    /// The current connectivity state of the wallet
    #[prost(enumeration = "check_connectivity_response::OnlineStatus", tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `CheckConnectivityResponse`.
pub mod check_connectivity_response {
    /// Describes the wallet's network connection state
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OnlineStatus {
        /// The wallet is attempting to connect to peers
        Connecting = 0,
        /// The wallet is successfully connected to peers
        Online = 1,
        /// The wallet is not connected to any peers
        Offline = 2,
    }
    impl OnlineStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OnlineStatus::Connecting => "Connecting",
                OnlineStatus::Online => "Online",
                OnlineStatus::Offline => "Offline",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Connecting" => Some(Self::Connecting),
                "Online" => Some(Self::Online),
                "Offline" => Some(Self::Offline),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEventRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEvent {
    #[prost(string, tag = "1")]
    pub event: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub source_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub dest_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub direction: ::prost::alloc::string::String,
    #[prost(uint64, tag = "7")]
    pub amount: u64,
    #[prost(bytes = "vec", tag = "9")]
    pub payment_id: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEventResponse {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<TransactionEvent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterValidatorNodeRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub validator_node_public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub validator_node_signature: ::core::option::Option<Signature>,
    #[prost(uint64, tag = "3")]
    pub fee_per_gram: u64,
    #[prost(bytes = "vec", tag = "5")]
    pub payment_id: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterValidatorNodeResponse {
    #[prost(uint64, tag = "1")]
    pub transaction_id: u64,
    #[prost(bool, tag = "2")]
    pub is_success: bool,
    #[prost(string, tag = "3")]
    pub failure_message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportTransactionsRequest {
    #[prost(string, tag = "1")]
    pub txs: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportTransactionsResponse {
    #[prost(uint64, repeated, tag = "1")]
    pub tx_ids: ::prost::alloc::vec::Vec<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllCompletedTransactionsRequest {
    #[prost(uint64, tag = "1")]
    pub offset: u64,
    #[prost(uint64, tag = "2")]
    pub limit: u64,
    #[prost(uint64, tag = "3")]
    pub status_bitflag: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllCompletedTransactionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<TransactionInfo>,
}
/// Request message for getting transactions at a specific block height
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockHeightTransactionsRequest {
    /// The block height to fetch transactions for
    #[prost(uint64, tag = "1")]
    pub block_height: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockHeightTransactionsResponse {
    /// List of transactions mined at the specified block height
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<TransactionInfo>,
}
/// Request message for GetTransactionPayRefs RPC.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionPayRefsRequest {
    /// The transaction ID to retrieve PayRefs for.
    #[prost(uint64, tag = "1")]
    pub transaction_id: u64,
}
/// Response message for GetTransactionPayRefs RPC.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionPayRefsResponse {
    /// List of PayRefs (32-byte payment references) for the transaction.
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub payment_references: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// Response message for GetTransactionsWithPayRefs RPC.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionsWithPayRefsResponse {
    /// The transaction information.
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<TransactionInfo>,
    /// List of PayRefs associated with this transaction.
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub payment_references: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Number of unique recipients for this transaction.
    #[prost(uint64, tag = "3")]
    pub recipient_count: u64,
}
/// Request message for getting payment details by payment reference
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPaymentByReferenceRequest {
    /// The 32-byte payment reference hash to look up
    #[prost(bytes = "vec", tag = "1")]
    pub payment_reference: ::prost::alloc::vec::Vec<u8>,
}
/// Response message containing transaction information for a payment reference
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPaymentByReferenceResponse {
    /// The transaction information if PayRef is found (optional).
    /// Returns full transaction details
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<TransactionInfo>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionDirection {
    Unknown = 0,
    Inbound = 1,
    Outbound = 2,
}
impl TransactionDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TransactionDirection::Unknown => "TRANSACTION_DIRECTION_UNKNOWN",
            TransactionDirection::Inbound => "TRANSACTION_DIRECTION_INBOUND",
            TransactionDirection::Outbound => "TRANSACTION_DIRECTION_OUTBOUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_DIRECTION_UNKNOWN" => Some(Self::Unknown),
            "TRANSACTION_DIRECTION_INBOUND" => Some(Self::Inbound),
            "TRANSACTION_DIRECTION_OUTBOUND" => Some(Self::Outbound),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionStatus {
    /// This transaction has been completed between the parties but has not been broadcast to the base layer network.
    Completed = 0,
    /// This transaction has been broadcast to the base layer network and is currently in one or more base node mempools.
    Broadcast = 1,
    /// This transaction has been mined and included in a block.
    MinedUnconfirmed = 2,
    /// This transaction was generated as part of importing a spendable UTXO
    Imported = 3,
    /// This transaction is still being negotiated by the parties
    Pending = 4,
    /// This is a created Coinbase Transaction
    Coinbase = 5,
    /// This transaction is mined and confirmed at the current base node's height
    MinedConfirmed = 6,
    /// The transaction was rejected by the mempool
    Rejected = 7,
    /// This is faux transaction mainly for one-sided transaction outputs or wallet recovery outputs have been found
    OneSidedUnconfirmed = 8,
    /// All Imported and FauxUnconfirmed transactions will end up with this status when the outputs have been confirmed
    OneSidedConfirmed = 9,
    /// This transaction is still being queued for sending
    Queued = 10,
    /// The transaction was not found by the wallet its in transaction database
    NotFound = 11,
    /// This is Coinbase transaction that is detected from chain
    CoinbaseUnconfirmed = 12,
    /// This is Coinbase transaction that is detected from chain
    CoinbaseConfirmed = 13,
    /// This is Coinbase transaction that is not currently detected as mined
    CoinbaseNotInBlockChain = 14,
}
impl TransactionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TransactionStatus::Completed => "TRANSACTION_STATUS_COMPLETED",
            TransactionStatus::Broadcast => "TRANSACTION_STATUS_BROADCAST",
            TransactionStatus::MinedUnconfirmed => "TRANSACTION_STATUS_MINED_UNCONFIRMED",
            TransactionStatus::Imported => "TRANSACTION_STATUS_IMPORTED",
            TransactionStatus::Pending => "TRANSACTION_STATUS_PENDING",
            TransactionStatus::Coinbase => "TRANSACTION_STATUS_COINBASE",
            TransactionStatus::MinedConfirmed => "TRANSACTION_STATUS_MINED_CONFIRMED",
            TransactionStatus::Rejected => "TRANSACTION_STATUS_REJECTED",
            TransactionStatus::OneSidedUnconfirmed => {
                "TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED"
            }
            TransactionStatus::OneSidedConfirmed => {
                "TRANSACTION_STATUS_ONE_SIDED_CONFIRMED"
            }
            TransactionStatus::Queued => "TRANSACTION_STATUS_QUEUED",
            TransactionStatus::NotFound => "TRANSACTION_STATUS_NOT_FOUND",
            TransactionStatus::CoinbaseUnconfirmed => {
                "TRANSACTION_STATUS_COINBASE_UNCONFIRMED"
            }
            TransactionStatus::CoinbaseConfirmed => {
                "TRANSACTION_STATUS_COINBASE_CONFIRMED"
            }
            TransactionStatus::CoinbaseNotInBlockChain => {
                "TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_STATUS_COMPLETED" => Some(Self::Completed),
            "TRANSACTION_STATUS_BROADCAST" => Some(Self::Broadcast),
            "TRANSACTION_STATUS_MINED_UNCONFIRMED" => Some(Self::MinedUnconfirmed),
            "TRANSACTION_STATUS_IMPORTED" => Some(Self::Imported),
            "TRANSACTION_STATUS_PENDING" => Some(Self::Pending),
            "TRANSACTION_STATUS_COINBASE" => Some(Self::Coinbase),
            "TRANSACTION_STATUS_MINED_CONFIRMED" => Some(Self::MinedConfirmed),
            "TRANSACTION_STATUS_REJECTED" => Some(Self::Rejected),
            "TRANSACTION_STATUS_ONE_SIDED_UNCONFIRMED" => Some(Self::OneSidedUnconfirmed),
            "TRANSACTION_STATUS_ONE_SIDED_CONFIRMED" => Some(Self::OneSidedConfirmed),
            "TRANSACTION_STATUS_QUEUED" => Some(Self::Queued),
            "TRANSACTION_STATUS_NOT_FOUND" => Some(Self::NotFound),
            "TRANSACTION_STATUS_COINBASE_UNCONFIRMED" => Some(Self::CoinbaseUnconfirmed),
            "TRANSACTION_STATUS_COINBASE_CONFIRMED" => Some(Self::CoinbaseConfirmed),
            "TRANSACTION_STATUS_COINBASE_NOT_IN_BLOCK_CHAIN" => {
                Some(Self::CoinbaseNotInBlockChain)
            }
            _ => None,
        }
    }
}
/// Enum for payment direction
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PaymentDirection {
    /// Unknown or unspecified direction
    Unknown = 0,
    /// Payment received by this wallet
    Inbound = 1,
    /// Payment sent from this wallet
    Outbound = 2,
}
impl PaymentDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PaymentDirection::Unknown => "PAYMENT_DIRECTION_UNKNOWN",
            PaymentDirection::Inbound => "PAYMENT_DIRECTION_INBOUND",
            PaymentDirection::Outbound => "PAYMENT_DIRECTION_OUTBOUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAYMENT_DIRECTION_UNKNOWN" => Some(Self::Unknown),
            "PAYMENT_DIRECTION_INBOUND" => Some(Self::Inbound),
            "PAYMENT_DIRECTION_OUTBOUND" => Some(Self::Outbound),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod wallet_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The gRPC interface for interacting with the wallet.
    #[derive(Debug, Clone)]
    pub struct WalletClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WalletClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WalletClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WalletClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            WalletClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "GetVersion"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the current operational state of the wallet.
        ///
        /// This RPC provides an overview of the wallet's internal status, including:
        /// - The latest blockchain height scanned by the wallet
        /// - The current balance (available, pending incoming/outgoing)
        /// - Network connectivity status with the base node
        ///
        /// This is commonly used by UI clients or backend systems to confirm the wallet is healthy,
        /// synchronized, and connected to the Tari network.
        ///
        /// Example usage (JavaScript):
        /// ```javascript
        /// const response = await client.getState({});
        /// console.log(response.scanned_height); // e.g., 1523493
        /// console.log(response.balance.available_balance); // e.g., 1234567890
        /// console.log(response.network.status); // e.g., "Online"
        /// ```
        ///
        /// Example response:
        /// ```json
        /// {
        ///   "scanned_height": 1523493,
        ///   "balance": {
        ///     "available_balance": 1234567890,
        ///     "pending_incoming_balance": 100000000,
        ///     "pending_outgoing_balance": 0
        ///   },
        ///   "network": {
        ///     "status": "Online",
        ///     "avg_latency_ms": 28,
        ///     "num_node_connections": 8
        ///   }
        /// }
        /// ```
        pub async fn get_state(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tari.rpc.Wallet/GetState");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tari.rpc.Wallet", "GetState"));
            self.inner.unary(req, path, codec).await
        }
        /// This RPC returns a lightweight response indicating whether the wallet is connected to the network, attempting to connect, or currently offline. This is useful for UIs or clients to determine if network interactions like transactions or syncs are possible.
        ///
        /// Example usage (JavaScript):
        /// ```javascript
        /// const response = await client.checkConnectivity({});
        /// console.log(response.status); // e.g., 1 (Online)
        /// ```
        ///
        /// Example response:
        /// ```json
        /// {
        ///   "status": "Online"
        /// }
        /// ```
        pub async fn check_connectivity(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectivityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CheckConnectivityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/CheckConnectivity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "CheckConnectivity"));
            self.inner.unary(req, path, codec).await
        }
        /// Check for new updates
        pub async fn check_for_updates(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<tonic::Response<super::SoftwareUpdate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/CheckForUpdates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "CheckForUpdates"));
            self.inner.unary(req, path, codec).await
        }
        /// The `Identify` RPC call returns the identity information of the wallet node.
        /// This includes:
        /// - **Public Key**: The wallet's cryptographic public key.
        /// - **Public Address**: The wallet's public address used to receive funds.
        /// - **Node ID**: The unique identifier of the wallet node in the network.
        ///
        /// Example usage (JavaScript):
        /// ```javascript
        /// // Call the Identify RPC method
        /// client.Identify({}, (error, response) => {
        ///   if (error) {
        ///     console.error('Error:', error);
        ///   } else {
        ///     console.log('Identity Response:', response);
        ///   }
        /// });
        /// ```
        ///
        /// **Sample JSON Response:**
        ///
        /// ```json
        /// {
        ///   "public_key": "0x04b2c5f3fe65bb1c3cde019e34f3eab1234598c820dca43bbf4d5686a980ddc69e0d4b180d85990d0a5e4aee46e0a6ad9283f0a41783992a70c548e53e47321fa",
        ///   "public_address": "14HVCEeZC2RGE4SDn3yGwqzXepJ2LDqXva7kb4fherYMQR9dF7341T3TjMZobB1a6xouGvS5SXwEvXKwK3zLz2rgReh",
        ///   "node_id": "0x1234abcd5678efgh9012ijkl3456mnop"
        /// }
        /// ```
        pub async fn identify(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIdentityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetIdentityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tari.rpc.Wallet/Identify");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tari.rpc.Wallet", "Identify"));
            self.inner.unary(req, path, codec).await
        }
        /// This RPC returns two types of wallet addresses: interactive and one-sided addresses.
        /// It provides these addresses in byte format as part of the response.
        /// - **Interactive Address**: This is a type of address used for interaction and communication with the wallet.
        /// - **One-Sided Address**: This is another address type, typically used in scenarios where a one-way interaction or transaction is needed.
        ///
        /// Example usage (JavaScript):
        /// // Call the GetAddress RPC method
        /// client.GetAddress({}, (error, response) => {
        ///   if (error) {
        ///     console.error('Error:', error);
        ///   } else {
        ///     console.log('Address Response:', response);
        ///   }
        /// });
        /// ```
        ///
        /// **Sample JSON Response:**
        ///  // ```json
        /// {
        ///   "interactive_address": "0x14b27bde3f7d9c9d7455f16b056a3c439c663af93356f56e16d2b2c79e6995c44c9c6c7c",
        ///   "one_sided_address": "0x12b35ddcb2270a72d7b327abc7cd4f607a492c6e13e72e65c34742069e48bd3bc462df63"
        /// }
        /// ```
        pub async fn get_address(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::GetAddressResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetAddress",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "GetAddress"));
            self.inner.unary(req, path, codec).await
        }
        /// This RPC returns addresses generated for a specific payment ID. It provides both the interactive
        /// and one-sided addresses for the given payment ID, along with their respective representations in
        /// base58 and emoji formats.
        ///
        /// Example usage (JavaScript):
        ///
        /// ```javascript
        /// // Prepare the payment ID for the request
        /// const paymentId = Buffer.from('your_payment_id_here', 'hex');
        /// const request = { payment_id: paymentId };
        ///
        /// // Call the GetPaymentIdAddress RPC method
        /// client.GetPaymentIdAddress(request, (error, response) => {
        ///   if (error) {
        ///     console.error('Error:', error);
        ///   } else {
        ///     console.log('Payment ID Address Response:', response);
        ///   }
        /// });
        /// ```
        ///
        /// **Sample JSON Response:**
        ///
        /// ```json
        /// {
        ///  "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
        ///  "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
        ///  "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
        ///  "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
        ///  "interactive_address_emoji": "🐢🌊💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭",
        ///  "one_sided_address_emoji": "🐢📟💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞📜.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭"
        /// }
        /// ```
        ///
        pub async fn get_payment_id_address(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPaymentIdAddressRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetCompleteAddressResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetPaymentIdAddress",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "GetPaymentIdAddress"));
            self.inner.unary(req, path, codec).await
        }
        /// This RPC call that retrieves the current wallet's interactive and one-sided addresses in multiple formats and returns them in a structured response.
        /// The response includes:
        /// - Raw binary
        /// - Base58-encoded (human-readable)
        /// - Emoji-encoded (for fun and friendliness)
        ///
        /// Example usage (JavaScript with gRPC):
        ///
        /// ```js
        /// const client = new WalletClient('localhost:50051', grpc.credentials.createInsecure());
        /// client.getCompleteAddress({}, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log(response);
        /// });
        /// ```
        ///
        /// Sample response:
        /// ```json
        /// {
        ///  "interactive_address": "0411aabbccddeeff00112233445566778899aabbccddeeff0011223344556677",
        ///  "one_sided_address": "02ff8899aabbccddeeff00112233445566778899aabbccddeeff001122334455",
        ///  "interactive_address_base58": "14HVCEeZC2RGE4SDn3yG.....6xouGvS5SXwEvXKwK3zLz2rgReh",
        ///  "one_sided_address_base58": "12HVCEeZC2RGE4SDn3yGwqz.....obB1a6xouGvS5SXwEvXKwK3zLz2rgReL",
        ///  "interactive_address_emoji": "🐢🌊💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭",
        ///  "one_sided_address_emoji": "🐢📟💤🔌🚑🐛🏦⚽🍓🐭🚁🎢🔪🥐👛🍞📜.....🍐🍟💵🎉🍯🎁🎾🎼💻💄🍳🍐🤔🥝🍫👅🚀🐬🎭"
        /// }
        /// ```
        pub async fn get_complete_address(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::GetCompleteAddressResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetCompleteAddress",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "GetCompleteAddress"));
            self.inner.unary(req, path, codec).await
        }
        /// This call supports standard interactive transactions (Mimblewimble),
        /// one-sided transactions, and one-sided-to-stealth-address transactions.
        /// Each recipient must include a valid Tari address, amount, fee, and payment type.
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// const recipient = new PaymentRecipient();
        /// recipient.setAddress("14HVCEeZ...");
        /// recipient.setAmount(1000000); // 1 T
        /// recipient.setFeePerGram(25);
        /// recipient.setPaymentType(PaymentType.ONE_SIDED);
        /// recipient.setPaymentId(Buffer.from("abc123", "utf-8"));
        ///
        /// const request = new TransferRequest();
        /// request.setRecipientsList([recipient]);
        ///
        /// client.transfer(request, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log(response.toObject());
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        ///
        /// ```json
        /// {
        ///   "results": [
        ///     {
        ///       "address": "14HVCEeZ...",
        ///       "transaction_id": 12345,
        ///       "is_success": true,
        ///       "failure_message": ""
        ///     }
        ///   ]
        /// }
        pub async fn transfer(
            &mut self,
            request: impl tonic::IntoRequest<super::TransferRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TransferResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/tari.rpc.Wallet/Transfer");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tari.rpc.Wallet", "Transfer"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the transaction details for the given transaction IDs.
        ///
        /// The GetTransactionInfo RPC retrieves detailed information about specific transactions based on their IDs.
        /// The response includes details such as transaction status, direction, amount, fee, and more.
        ///
        /// ### Request Parameters:
        ///
        /// - `transaction_ids` (required):
        ///   - **Type**: `repeated uint64`
        ///   - **Description**: A list of transaction IDs to query.
        ///   - **Restrictions**:
        ///     - Must contain at least one ID.
        ///     - All IDs must be valid unsigned 64-bit integers.
        ///     - Duplicates will be ignored; only the first occurrence is processed.
        ///     - If a transaction ID is not found, it will be returned with a `status` of `NOT_FOUND`.
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// const request = { transaction_ids: [12345, 67890] };
        /// client.getTransactionInfo(request, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log(response.transactions);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        ///
        /// ```json
        /// {
        ///   "transactions": [
        ///     {
        ///       "tx_id": 12345,
        ///       "source_address": "0x1234abcd...",
        ///       "dest_address": "0x5678efgh...",
        ///       "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
        ///       "direction": "TRANSACTION_DIRECTION_OUTBOUND",
        ///       "amount": 1000000,
        ///       "fee": 25,
        ///       "is_cancelled": false,
        ///       "excess_sig": "0xabcdef...",
        ///       "timestamp": 1681234567,
        ///       "payment_id": "0xdeadbeef...",
        ///       "mined_in_block_height": 1523493
        ///     }
        ///   ]
        /// }
        pub async fn get_transaction_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetTransactionInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "GetTransactionInfo"));
            self.inner.unary(req, path, codec).await
        }
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// const request = {
        ///   payment_id: {
        ///     utf8_string: "invoice-001"
        ///   }
        /// };
        /// const call = client.getCompletedTransactions(request);
        /// call.on('data', (response) => {
        ///   console.log(response.transaction);
        /// });
        /// call.on('error', console.error);
        /// call.on('end', () => console.log("Stream ended"));
        /// ```
        ///
        /// ### Sample Streamed JSON Response:
        ///
        /// ```json
        /// {
        ///   "transaction": {
        ///     "tx_id": 12345,
        ///     "source_address": "0x1234abcd...",
        ///     "dest_address": "0x5678efgh...",
        ///     "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
        ///     "direction": "TRANSACTION_DIRECTION_INBOUND",
        ///     "amount": 500000,
        ///     "fee": 20,
        ///     "is_cancelled": false,
        ///     "excess_sig": "0xabcdef...",
        ///     "timestamp": 1681234567,
        ///     "payment_id": "0xdeadbeef...",
        ///     "mined_in_block_height": 1523493
        ///   }
        /// }
        /// ```
        pub async fn get_completed_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCompletedTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::GetCompletedTransactionsResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetCompletedTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "GetCompletedTransactions"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Returns all transactions that were mined at a specific block height.
        ///
        /// The `GetBlockHeightTransactions` call retrieves all wallet transactions that were mined
        /// at the specified block height. The response includes all transactions in a single response,
        /// with each transaction including details such as status, direction, amount,
        /// fees, and associated metadata.
        ///
        /// ### Request Parameters:
        ///
        /// - `block_height` (required):
        ///   - **Type**: `uint64`
        ///   - **Description**: The specific block height to fetch transactions for.
        ///   - **Restrictions**:
        ///     - Must be a valid block height (greater than 0).
        ///     - If the block height is beyond the current chain height, no transactions will be returned.
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// const request = {
        ///   block_height: 1523493
        /// };
        /// const response = await client.getBlockHeightTransactions(request);
        /// console.log(response.transactions);
        /// ```
        ///
        /// ### Sample JSON Response:
        ///
        /// ```json
        /// {
        ///   "transactions": [
        ///     {
        ///       "tx_id": 12345,
        ///       "source_address": "0x1234abcd...",
        ///       "dest_address": "0x5678efgh...",
        ///       "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
        ///       "direction": "TRANSACTION_DIRECTION_INBOUND",
        ///       "amount": 500000,
        ///       "fee": 20,
        ///       "is_cancelled": false,
        ///       "excess_sig": "0xabcdef...",
        ///       "timestamp": 1681234567,
        ///       "payment_id": "0xdeadbeef...",
        ///       "mined_in_block_height": 1523493
        ///     }
        ///   ]
        /// }
        /// ```
        pub async fn get_block_height_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBlockHeightTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBlockHeightTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetBlockHeightTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tari.rpc.Wallet", "GetBlockHeightTransactions"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns all PayRefs (payment references) for a specific transaction.
        ///
        /// The `GetTransactionPayRefs` call retrieves all PayRefs associated with the specified
        /// transaction ID. PayRefs are cryptographic references generated from output hashes
        /// that allow recipients to verify payments without revealing sensitive transaction details.
        ///
        /// ### Request Parameters:
        ///
        /// - `transaction_id` (required):
        ///   - **Type**: `uint64`
        ///   - **Description**: The transaction ID to retrieve PayRefs for.
        ///   - **Restrictions**:
        ///     - Must be a valid transaction ID that exists in the wallet.
        ///     - If the transaction ID is invalid or not found, an error will be returned.
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// const request = {
        ///   transaction_id: 12345
        /// };
        /// const response = await client.getTransactionPayRefs(request);
        /// console.log("PayRefs:", response.payment_references.map(ref => Buffer.from(ref).toString('hex')));
        /// ```
        ///
        /// ### Sample JSON Response:
        ///
        /// ```json
        /// {
        ///   "payment_references": [
        ///     "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
        ///     "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"
        ///   ]
        /// }
        /// ```
        pub async fn get_transaction_pay_refs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionPayRefsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetTransactionPayRefsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetTransactionPayRefs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "GetTransactionPayRefs"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the wallet balance details.
        ///
        /// The `GetBalance` call retrieves the current balance status of the wallet,
        /// optionally filtered by a specific `payment_id`. The response includes detailed
        /// breakdowns of available, pending incoming/outgoing, and timelocked balances.
        ///
        /// ### Request Parameters:
        ///
        /// - `payment_id` (optional):
        ///   - **Type**: `UserPaymentId` (one of several formats).
        ///   - **Description**: An optional filter to retrieve the balance associated with a specific payment ID.
        ///   - **Accepted Formats** (must provide **only one**):
        ///     - `u256`: a 32-byte hexadecimal identifier.
        ///     - `utf8_string`: a human-readable string ID.
        ///     - `user_bytes`: raw binary bytes.
        ///   - **Restrictions**:
        ///     - Only one format must be provided at a time.
        ///     - If multiple or no formats are provided within `payment_id`, the request will return an error.
        ///     - If `payment_id` is omitted, the total wallet balance is returned.
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// const request = {
        ///   payment_id: {
        ///     utf8_string: "invoice-002"
        ///   }
        /// };
        /// client.getBalance(request, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log("Balance:", response);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        ///
        /// ```json
        /// {
        ///   "available_balance": 950000,
        ///   "pending_incoming_balance": 200000,
        ///   "pending_outgoing_balance": 50000,
        ///   "timelocked_balance": 100000
        /// }
        /// ```
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetBalance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the total value of unspent outputs in the wallet.
        ///
        /// The `GetUnspentAmounts` call retrieves the sum of all unspent output amounts
        /// currently held by the wallet. These are outputs that have not yet been spent or time-locked,
        /// and are available for future transactions.
        ///
        /// ### Request Parameters:
        ///
        /// - *(none)*
        ///   - This method uses an empty request body (`google.protobuf.Empty`).
        ///   - No filters or arguments are required.
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// client.getUnspentAmounts({}, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log("Total unspent amount:", response.amount);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        ///
        /// ```json
        /// {
        ///   "amount": 1250000
        /// }
        /// ```
        pub async fn get_unspent_amounts(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::GetUnspentAmountsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetUnspentAmounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "GetUnspentAmounts"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a transaction that splits funds into multiple smaller outputs.
        ///
        /// The `CoinSplit` call initiates a transaction that divides wallet funds into several equal-sized outputs.
        /// This is useful for preparing a wallet for many small transactions (e.g., for micropayments or batching).
        /// The resulting transaction is broadcast and can be tracked via its transaction ID.
        ///
        /// ### Request Parameters:
        ///
        /// - `amount_per_split` (required):
        ///   - **Type**: `uint64`
        ///   - **Description**: The value of each individual output in the split.
        ///   - **Restrictions**: Must be greater than zero.
        ///
        /// - `split_count` (required):
        ///   - **Type**: `uint64`
        ///   - **Description**: The number of outputs to create.
        ///   - **Restrictions**: Must be greater than zero and within practical system limits.
        ///
        /// - `fee_per_gram` (required):
        ///   - **Type**: `uint64`
        ///   - **Description**: The transaction fee rate (per gram of weight).
        ///   - **Restrictions**: Should be set high enough to ensure confirmation.
        ///
        /// - `lock_height` (optional):
        ///   - **Type**: `uint64`
        ///   - **Description**: The earliest block height at which the transaction becomes valid.
        ///   - **Restrictions**: Defaults to 0 if not specified.
        ///
        /// - `payment_id` (optional):
        ///   - **Type**: `bytes`
        ///   - **Description**: A user-defined identifier for tracking or referencing the transaction.
        ///   - **Restrictions**: Optional; can be left empty.
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// const request = {
        ///   amount_per_split: 100000,
        ///   split_count: 5,
        ///   fee_per_gram: 25,
        ///   lock_height: 0,
        ///   payment_id: new Uint8Array([])
        /// };
        /// client.coinSplit(request, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log("Created CoinSplit Tx ID:", response.tx_id);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        ///
        /// ```json
        /// {
        ///   "tx_id": 987654321
        /// }
        /// ```
        pub async fn coin_split(
            &mut self,
            request: impl tonic::IntoRequest<super::CoinSplitRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CoinSplitResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/CoinSplit",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("tari.rpc.Wallet", "CoinSplit"));
            self.inner.unary(req, path, codec).await
        }
        /// Imports UTXOs into the wallet as spendable outputs.
        ///
        /// The `ImportUtxos` call allows you to manually insert one or more previously received UTXOs
        /// into the wallet, marking them as spendable without needing rewindable metadata.
        /// Each UTXO is associated with a transaction ID in the response.
        ///
        /// ### Request Parameters:
        ///
        /// - `outputs` (required):
        ///   - **Type**: `repeated UnblindedOutput`
        ///   - **Description**: A list of unblinded outputs to import into the wallet.
        ///   - **Restrictions**:
        ///     - Each output must be valid and convertible to an internal UTXO format.
        ///     - The list must contain at least one item.
        ///
        /// - `payment_id` (optional):
        ///   - **Type**: `bytes`
        ///   - **Description**: An optional user-defined identifier to associate with the imported outputs.
        ///   - **Restrictions**:
        ///     - Can be left empty if not needed.
        ///     - Must be a valid byte string if provided.
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// const request = {
        ///   outputs: [/* array of unblinded outputs */],
        ///   payment_id: new Uint8Array([])
        /// };
        /// client.importUtxos(request, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log("Imported Tx IDs:", response.tx_ids);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        ///
        /// ```json
        /// {
        ///   "tx_ids": [101, 102, 103]
        /// }
        /// ```
        pub async fn import_utxos(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportUtxosRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ImportUtxosResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/ImportUtxos",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "ImportUtxos"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the wallet's current network connectivity status.
        ///
        /// The `GetNetworkStatus` call provides a snapshot of the wallet's connection to the Tari network,
        /// including whether it is online, the number of active peer connections, and the average latency
        /// to the configured base node.
        ///
        /// ### Request Parameters:
        ///
        /// - *(none)*
        ///   - This method uses an empty request body (`google.protobuf.Empty`).
        ///   - No filters or arguments are required.
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// client.getNetworkStatus({}, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log("Network Status:", response);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        ///
        /// ```json
        /// {
        ///   "status": "ONLINE",
        ///   "avg_latency_ms": 142,
        ///   "num_node_connections": 8
        /// }
        /// ```
        ///
        /// ### Status Field Values:
        ///
        /// The `status` field indicates the current network connectivity of the wallet. Possible values are:
        ///
        /// - `ONLINE`:
        ///   - The wallet is fully connected to the network and functioning normally.
        ///   - The node has enough active peer connections to operate efficiently.
        ///
        /// - `DEGRADED`:
        ///   - The wallet is connected to some peers but not enough to maintain full functionality.
        ///   - This could indicate issues with network connectivity, such as intermittent disconnections or insufficient peers, leading to reduced performance or reliability.
        ///
        /// - `OFFLINE`:
        ///   - The wallet is not connected to any peers.
        ///   - This status means the wallet is unable to communicate with the network and cannot perform any network-related operations.
        ///
        pub async fn get_network_status(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetNetworkStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "GetNetworkStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns a list of peers currently connected to the wallet.
        ///
        /// The `ListConnectedPeers` call retrieves information about peers that the wallet is currently
        /// connected to. This includes details such as peer addresses, connection status, supported protocols,
        /// and other metadata relevant to the connection.
        ///
        /// ### Request Parameters:
        ///
        /// - *(none)*
        ///   - This method uses an empty request body (`google.protobuf.Empty`).
        ///   - No filters or arguments are required.
        ///
        /// ### Response Fields:
        ///
        /// - **connected_peers**: List of peers currently connected to the wallet.
        ///   - **public_key**: The peer's public key (bytes).
        ///   - **node_id**: The unique node ID of the peer (bytes).
        ///   - **addresses**: List of the peer's addresses (repeated Address).
        ///   - **last_connection**: The timestamp of the last connection attempt (uint64).
        ///   - **flags**: Flags associated with the peer (uint32).
        ///   - **banned_until**: The timestamp until which the peer is banned (uint64, 0 if not banned).
        ///   - **banned_reason**: The reason for banning the peer (string, empty if not banned).
        ///   - **offline_at**: The timestamp indicating when the peer went offline (uint64, 0 if online).
        ///   - **features**: The features supported by the peer (uint32).
        ///   - **supported_protocols**: List of supported protocols by the peer (repeated bytes).
        ///   - **user_agent**: The user agent advertised by the peer (string).
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// client.listConnectedPeers({}, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log("Connected Peers:", response);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        ///
        /// ```json
        /// {
        ///   "connected_peers": [
        ///     {
        ///       "public_key": "0x1234abcd...",
        ///       "node_id": "0x5678efgh...",
        ///       "addresses": [
        ///         "127.0.0.1:18080",
        ///         "192.168.1.2:18080"
        ///       ],
        ///       "last_connection": 1625493123,
        ///       "flags": 1,
        ///       "banned_until": 0,
        ///       "banned_reason": "",
        ///       "offline_at": 0,
        ///       "features": 10,
        ///       "supported_protocols": [
        ///         "protocol_v1",
        ///         "protocol_v2"
        ///       ],
        ///       "user_agent": "TariBaseNode/1.0.0"
        ///     }
        ///   ]
        /// }
        /// ```
        pub async fn list_connected_peers(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::ListConnectedPeersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/ListConnectedPeers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "ListConnectedPeers"));
            self.inner.unary(req, path, codec).await
        }
        /// Cancels a specific transaction by its ID.
        ///
        /// The `CancelTransaction` call allows a transaction to be cancelled by its unique transaction ID (TxId).
        /// If the cancellation is successful, the response will indicate success. Otherwise, the response will
        /// contain a failure message with the reason for the failure.
        ///
        /// ### Request Parameters:
        ///
        /// - **tx_id**: The unique identifier for the transaction to be cancelled (uint64).
        ///
        /// ### Response Fields:
        ///
        /// - **is_success**: A boolean indicating whether the cancellation was successful (bool).
        ///   - `true` if the cancellation was successful, `false` if not.
        /// - **failure_message**: A string that provides the reason for the failure, if applicable (string).
        ///   - This field will be empty if the cancellation was successful.
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// const request = { tx_id: 12345 };
        /// client.cancelTransaction(request, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log(response);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        ///
        /// ```json
        /// {
        ///   "is_success": true,
        ///   "failure_message": ""
        /// }
        /// ```
        pub async fn cancel_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CancelTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/CancelTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "CancelTransaction"));
            self.inner.unary(req, path, codec).await
        }
        /// Will trigger a complete revalidation of all wallet outputs.
        pub async fn revalidate_all_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::RevalidateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RevalidateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/RevalidateAllTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "RevalidateAllTransactions"));
            self.inner.unary(req, path, codec).await
        }
        /// Will trigger a validation of all wallet outputs.
        pub async fn validate_all_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/ValidateAllTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "ValidateAllTransactions"));
            self.inner.unary(req, path, codec).await
        }
        /// Sends a XTR SHA Atomic Swap transaction.
        ///
        /// The `SendShaAtomicSwapTransaction` call is used to initiate an Atomic Swap
        /// transaction using SHA. It allows the sender to send a payment to the recipient
        /// in exchange for an atomic swap, with SHA used as the secret for the swap.
        /// The method accepts the recipient's information and initiates the transaction.
        ///
        /// ### Request Parameters:
        /// - **recipient** (required): A PaymentRecipient object containing the recipient's address,
        ///   the amount to be swapped, the fee per gram, and the payment ID to identify the transaction.
        ///
        /// ### Response Fields:
        /// - **transaction_id**: The ID of the transaction.
        /// - **pre_image**: The SHA pre-image of the atomic swap.
        /// - **output_hash**: The hash of the output associated with the transaction.
        /// - **is_success**: Indicates whether the transaction was successful (true) or failed (false).
        /// - **failure_message**: Provides an error message if the transaction failed.
        ///
        /// ### Example JavaScript gRPC client usage:
        /// ```javascript
        /// const request = {
        ///   recipient: {
        ///     address: "t1abc12345",
        ///     amount: 1000000,
        ///     fee_per_gram: 10,
        ///     payment_id: "0xdeadbeef"
        ///   }
        /// };
        /// client.sendShaAtomicSwapTransaction(request, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log(response);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        /// ```json
        /// {
        ///   "transaction_id": 123456789,
        ///   "pre_image": "0xabcdef1234567890",
        ///   "output_hash": "0x123456abcdef7890",
        ///   "is_success": true,
        ///   "failure_message": ""
        /// }
        pub async fn send_sha_atomic_swap_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::SendShaAtomicSwapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SendShaAtomicSwapResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/SendShaAtomicSwapTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tari.rpc.Wallet", "SendShaAtomicSwapTransaction"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a burn transaction for burning a specified amount of Tari currency.
        ///
        /// The `CreateBurnTransaction` call facilitates burning a certain amount of Tari
        /// by initiating a burn transaction. It allows the user to specify the amount to burn,
        /// along with a fee per gram and optionally a payment ID and claim public key.
        ///
        /// ### Request Parameters:
        /// - **amount** (required): The amount of Tari to be burned.
        /// - **fee_per_gram** (required): The fee per gram for the transaction.
        /// - **claim_public_key** (optional): The public key to claim ownership of the burned coins.
        /// - **payment_id** (optional): A unique identifier for the payment associated with the burn transaction.
        ///
        /// ### Response Fields:
        /// - **transaction_id**: The ID of the burn transaction.
        /// - **is_success**: Indicates whether the burn transaction was successfully created.
        /// - **failure_message**: Provides an error message if the transaction creation failed.
        /// - **commitment**: The commitment associated with the burn transaction.
        /// - **ownership_proof**: A proof of ownership for the burned coins.
        /// - **range_proof**: The range proof associated with the burned coins.
        /// - **reciprocal_claim_public_key**: The public key of the reciprocal claim for the burn.
        ///
        /// ### Example JavaScript gRPC client usage:
        /// ```javascript
        /// const request = {
        ///   amount: 1000000,
        ///   fee_per_gram: 10,
        ///   claim_public_key: "0xabcdef1234567890",
        ///   payment_id: "0xdeadbeef"
        /// };
        /// client.createBurnTransaction(request, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log(response);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        /// ```json
        /// {
        ///   "transaction_id": 123456789,
        ///   "is_success": true,
        ///   "failure_message": "",
        ///   "commitment": "0xcommitmenthash",
        ///   "ownership_proof": "0xownershipproof",
        ///   "range_proof": "0xrangeproof",
        ///   "reciprocal_claim_public_key": "0xreciprocalpublickey"
        /// }
        pub async fn create_burn_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBurnTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateBurnTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/CreateBurnTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "CreateBurnTransaction"));
            self.inner.unary(req, path, codec).await
        }
        /// Claims a SHA Atomic Swap transaction using a pre-image and output hash.
        ///
        /// The `ClaimShaAtomicSwapTransaction` call allows the user to unlock and claim funds from
        /// a hash-time-locked contract (HTLC) by supplying the correct pre-image that matches a
        /// previously committed SHA-256 hash. This pre-image proves the user's knowledge of the
        /// secret required to spend the output.
        ///
        /// ### Request Parameters:
        /// - **output** (required): The hex-encoded output hash (SHA-256 digest) that was locked in the atomic swap.
        /// - **pre_image** (required): The hex-encoded original pre-image (raw bytes, *not* hashed) which, when hashed with SHA-256, must match the `output` hash.
        /// - **fee_per_gram** (required): The transaction fee per gram, specified as an unsigned integer.
        ///
        /// ### Input Validation:
        /// - `output` must be a valid hex-encoded SHA-256 hash (64 hex characters).
        /// - `pre_image` must be a valid hex string representing the original secret (any byte length, commonly 32 bytes).
        /// - `fee_per_gram` must be a non-zero `uint64`; a fee of `0` may be rejected or deprioritized by the network.
        ///
        /// ### Response Fields:
        /// - **results**: A `TransferResult` object containing transaction ID, success status, and an error message if applicable.
        ///
        /// ### Example JavaScript gRPC client usage:
        /// ```javascript
        /// const request = {
        ///   output: "3e1f89af...e923", // SHA-256 hash of the expected pre-image
        ///   pre_image: "6a1b2c...eaf1", // raw pre-image (not hashed)
        ///   fee_per_gram: 10
        /// };
        /// client.claimShaAtomicSwapTransaction(request, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log(response.results);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        /// ```json
        /// {
        ///   "results": {
        ///     "address": "",
        ///     "transaction_id": 789654,
        ///     "is_success": true,
        ///     "failure_message": ""
        ///   }
        /// }
        pub async fn claim_sha_atomic_swap_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::ClaimShaAtomicSwapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ClaimShaAtomicSwapResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/ClaimShaAtomicSwapTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tari.rpc.Wallet", "ClaimShaAtomicSwapTransaction"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Claims an HTLC refund transaction after the timelock period has passed.
        ///
        /// The `ClaimHtlcRefundTransaction` call enables the original sender of a Hash Time-Locked Contract (HTLC)
        /// to reclaim the locked funds if the recipient has not claimed them in time using the correct pre-image.
        /// This is possible only after the output's timelock has expired.
        ///
        /// ### Request Parameters:
        /// - **output_hash** (required): Hex-encoded SHA-256 hash of the HTLC output being refunded.
        /// - **fee_per_gram** (required): Transaction fee per gram, specified as a `uint64`.
        ///
        /// ### Input Validation:
        /// - `output_hash` must be a valid 64-character hex string representing the hash of the HTLC output.
        /// - `fee_per_gram` must be a non-zero `uint64` value.
        ///
        /// ### Response Fields:
        /// - **results**: A `TransferResult` object including transaction ID, success status, and failure reason if any.
        ///
        /// ### Example JavaScript gRPC client usage:
        /// ```javascript
        /// const request = {
        ///   output_hash: "aabbccddeeff0011...99",
        ///   fee_per_gram: 20
        /// };
        /// client.claimHtlcRefundTransaction(request, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log(response.results);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        /// ```json
        /// {
        ///   "results": {
        ///     "address": "",
        ///     "transaction_id": 889977,
        ///     "is_success": true,
        ///     "failure_message": ""
        ///   }
        /// }
        pub async fn claim_htlc_refund_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::ClaimHtlcRefundRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ClaimHtlcRefundResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/ClaimHtlcRefundTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tari.rpc.Wallet", "ClaimHtlcRefundTransaction"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a transaction with a template registration output
        pub async fn create_template_registration(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTemplateRegistrationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateTemplateRegistrationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/CreateTemplateRegistration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tari.rpc.Wallet", "CreateTemplateRegistration"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// The SetBaseNode call configures the base node peer for the wallet.
        ///
        /// This RPC sets the public key and network address of the base node peer that the wallet should communicate with.
        ///
        /// ### Request Fields:
        /// - `public_key_hex` (string): The public key of the base node, provided as a hex string.
        /// - `net_address` (string): The multiaddress of the base node (e.g., `/ip4/127.0.0.1/tcp/18141`).
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// const request = {
        ///   public_key_hex: "0281bdfc...",
        ///   net_address: "/ip4/127.0.0.1/tcp/18141"
        /// };
        /// client.setBaseNode(request, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log("Base node set successfully");
        /// });
        /// ```
        ///
        /// ### Sample JSON Request:
        /// ```json
        /// {
        ///   "public_key_hex": "0281bdfc...",
        ///   "net_address": "/ip4/127.0.0.1/tcp/18141"
        /// }
        /// ```
        ///
        /// ### Sample JSON Response:
        /// ```json
        /// {}
        /// ```
        pub async fn set_base_node(
            &mut self,
            request: impl tonic::IntoRequest<super::SetBaseNodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetBaseNodeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/SetBaseNode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "SetBaseNode"));
            self.inner.unary(req, path, codec).await
        }
        /// ### Example JavaScript gRPC client usage:
        /// ```javascript
        /// const call = client.streamTransactionEvents({});
        ///
        /// call.on("data", (response) => {
        ///   console.log("Transaction Event:", response.transaction);
        /// });
        ///
        /// call.on("end", () => {
        ///   console.log("Stream ended.");
        /// });
        ///
        /// call.on("error", (err) => {
        ///   console.error("Stream error:", err);
        /// });
        /// ```
        ///
        /// ### Sample JSON Streamed Response:
        /// ```json
        /// {
        ///   "transaction": {
        ///     "event": "Mined",
        ///     "tx_id": "103248",
        ///     "source_address": "0xabc123...",
        ///     "dest_address": "0xdef456...",
        ///     "status": "Completed",
        ///     "direction": "Outbound",
        ///     "amount": 100000000,
        ///     "payment_id": "0xdeadbeef..."
        ///   }
        /// }
        /// ```
        pub async fn stream_transaction_events(
            &mut self,
            request: impl tonic::IntoRequest<super::TransactionEventRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TransactionEventResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/StreamTransactionEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "StreamTransactionEvents"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn register_validator_node(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterValidatorNodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterValidatorNodeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/RegisterValidatorNode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "RegisterValidatorNode"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn import_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ImportTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/ImportTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "ImportTransactions"));
            self.inner.unary(req, path, codec).await
        }
        /// Get all completed transactions including cancelled ones, sorted by timestamp and paginated
        pub async fn get_all_completed_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAllCompletedTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAllCompletedTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetAllCompletedTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tari.rpc.Wallet", "GetAllCompletedTransactions"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets transaction information by payment reference (PayRef)
        ///
        /// The `GetPaymentByReference` call retrieves transaction information using a 32-byte payment reference hash.
        /// PayRefs are generated as Blake2b_256(block_hash || output_hash) and provide a stable way to look up
        /// transactions even after outputs are spent.
        ///
        /// ### Request Parameters:
        ///
        /// - `payment_reference` (required):
        ///   - **Type**: `bytes` (32 bytes)
        ///   - **Description**: The payment reference hash to look up
        ///   - **Restrictions**: Must be exactly 32 bytes representing a valid PayRef
        ///
        /// ### Example JavaScript gRPC client usage:
        ///
        /// ```javascript
        /// const payref = Buffer.from('a1b2c3d4e5f6789012345678901234567890123456789012345678901234567890', 'hex');
        /// const request = { payment_reference: payref };
        /// client.getPaymentByReference(request, (err, response) => {
        ///   if (err) console.error(err);
        ///   else console.log('Transaction found:', response.transaction);
        /// });
        /// ```
        ///
        /// ### Sample JSON Response:
        ///
        /// ```json
        /// {
        ///   "transaction": {
        ///     "tx_id": 12345,
        ///     "source_address": "0x1234abcd...",
        ///     "dest_address": "0x5678efgh...",
        ///     "status": "TRANSACTION_STATUS_MINED_CONFIRMED",
        ///     "direction": "TRANSACTION_DIRECTION_INBOUND",
        ///     "amount": 1000000,
        ///     "fee": 20,
        ///     "is_cancelled": false,
        ///     "excess_sig": "0xabcdef...",
        ///     "timestamp": 1681234567,
        ///     "payment_id": "0xdeadbeef...",
        ///     "mined_in_block_height": 150000
        ///   }
        /// }
        /// ```
        pub async fn get_payment_by_reference(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPaymentByReferenceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPaymentByReferenceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tari.rpc.Wallet/GetPaymentByReference",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tari.rpc.Wallet", "GetPaymentByReference"));
            self.inner.unary(req, path, codec).await
        }
    }
}
