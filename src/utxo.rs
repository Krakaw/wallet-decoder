pub mod types;
pub mod range_proof;
pub mod scanner;
pub mod rpc_generated; // For files generated by tonic_build
pub mod rpc;           // For re-exporting and potentially wrapping gRPC client logic

use tari_crypto::{
    commitment::HomomorphicCommitmentFactory,
    extended_range_proof::{RistrettoAggregatedPublicStatement, Statement},
    ristretto::RistrettoRangeProofService,
};

use crate::error::TransactionError;
use crate::utxo::types::Utxo;

pub fn verify_range_proof(
    utxo: &Utxo,
    range_proof_service: &RistrettoRangeProofService,
) -> Result<(), TransactionError> {
    let proof = utxo
        .proof
        .as_ref()
        .ok_or_else(|| TransactionError::RangeProofError("Range proof not found in Utxo".to_string()))?;

    let commitment_obj = utxo.commitment.to_commitment()?;

    // Construct the statement for verification.
    // The 'value' field in Utxo is u64, which matches minimum_value_promise.
    let statement = RistrettoAggregatedPublicStatement {
        statements: vec![Statement {
            commitment: commitment_obj,
            minimum_value_promise: utxo.value,
        }],
    };

    // Verify the proof.
    // The verify_batch method expects Vec<&[u8]> for proofs and Vec<&RistrettoAggregatedPublicStatement>.
    // proof.0 is CryptoRangeProof, which has a to_vec() method.
    range_proof_service.verify_batch(vec![&proof.0.to_vec()], vec![&statement])?;

    Ok(())
}

pub fn create_range_proof_service() -> RistrettoRangeProofService {
    let factory = HomomorphicCommitmentFactory::default();
    RistrettoRangeProofService::new(&factory)
}

#[cfg(test)]
mod tests {
    use super::*; // To import verify_range_proof, create_range_proof_service
    use crate::utxo::{range_proof::RangeProof as UtxoRangeProof, types::OutputType}; // Our wrapper
    use tari_common_types::types::{Commitment, CompressedCommitment, PrivateKey};
    use tari_crypto::{
        commitment::HomomorphicCommitmentFactory,
        keys::SecretKey, // For PrivateKey::from_canonical_bytes or similar
        ristretto::RangeProof as CryptoRangeProof, // The actual proof from tari_crypto
    };

    #[test]
    fn test_verify_no_range_proof() {
        let service = create_range_proof_service();
        // Create a dummy commitment (32 bytes of zeros for simplicity in this specific test)
        let dummy_commitment_bytes = vec![0u8; Commitment::commitment_size()];
        let compressed_commitment = CompressedCommitment::from_canonical_bytes(&dummy_commitment_bytes)
            .expect("Failed to create CompressedCommitment from bytes");

        let utxo_no_proof = Utxo {
            output_hash: "test_hash".to_string(),
            value: 100,
            block_height: 100,
            script_pubkey: "test_script_pubkey".to_string(),
            output_type: OutputType::Standard,
            proof: None,
            commitment: compressed_commitment,
        };

        match verify_range_proof(&utxo_no_proof, &service) {
            Err(TransactionError::RangeProofError(msg)) => {
                assert_eq!(msg, "Range proof not found in Utxo");
            }
            _ => panic!("Expected RangeProofError for missing proof"),
        }
    }

    fn generate_valid_proof_and_commitment(
        value: u64,
    ) -> (CryptoRangeProof, CompressedCommitment, PrivateKey) {
        let factory = HomomorphicCommitmentFactory::default();
        let service = create_range_proof_service(); // Uses the same factory logic

        // Blinding factor (mask) - IMPORTANT for valid proof
        let blinding_factor = PrivateKey::random(&mut rand::rngs::OsRng); // Generate a random blinding factor

        // Create commitment: C = vG + hH where v is value, h is blinding_factor
        // The factory.commit takes blinding_factor first, then value_as_private_key
        let value_as_private_key = PrivateKey::from(value); // Convert value to PrivateKey for commitment
        let commitment = factory.commit(&blinding_factor, &value_as_private_key);

        // Construct proof using the blinding_factor (mask) and value
        // RistrettoRangeProofService::construct_proof expects the mask (blinding_factor) and value.
        let proof = service
            .construct_proof(&blinding_factor, value)
            .expect("Failed to construct proof");

        (
            proof,
            CompressedCommitment::from_commitment(&commitment)
                .expect("Failed to compress commitment"),
            blinding_factor,
        )
    }

    #[test]
    fn test_verify_valid_range_proof() {
        let service = create_range_proof_service();
        let value = 1500u64;
        let (crypto_proof, compressed_commitment, _) = generate_valid_proof_and_commitment(value);

        let utxo = Utxo {
            output_hash: "valid_proof_hash".to_string(),
            value,
            block_height: 100,
            script_pubkey: "test_script_pubkey".to_string(),
            output_type: OutputType::Standard,
            proof: Some(UtxoRangeProof(crypto_proof)),
            commitment: compressed_commitment,
        };

        assert!(verify_range_proof(&utxo, &service).is_ok());
    }

    #[test]
    fn test_verify_invalid_range_proof_modified_bytes() {
        let service = create_range_proof_service();
        let value = 2000u64;
        let (crypto_proof, compressed_commitment, _) = generate_valid_proof_and_commitment(value);

        // Modify the proof to make it invalid
        let mut proof_bytes = crypto_proof.to_vec();
        if !proof_bytes.is_empty() {
            proof_bytes[0] = proof_bytes[0].wrapping_add(1); // Flip a bit
        } else {
            // Proofs are typically not empty, but handle this edge case for robustness
            // If proof is empty (which it shouldn't be for Bulletproofs+), this test might not be meaningful
            // or we might need a different way to invalidate. For now, assume it's not empty.
            panic!("Generated proof is empty, cannot modify bytes");
        }
        let modified_crypto_proof = CryptoRangeProof::from_bytes(&proof_bytes)
            .expect("Failed to create CryptoRangeProof from modified bytes");

        let utxo = Utxo {
            output_hash: "invalid_bytes_hash".to_string(),
            value,
            block_height: 100,
            script_pubkey: "test_script_pubkey".to_string(),
            output_type: OutputType::Standard,
            proof: Some(UtxoRangeProof(modified_crypto_proof)),
            commitment: compressed_commitment,
        };

        match verify_range_proof(&utxo, &service) {
            Err(TransactionError::CryptoError(_)) => { /* Expected */ }
            Ok(_) => panic!("Expected CryptoError for modified proof bytes"),
            Err(e) => panic!("Expected CryptoError, got {:?}", e),
        }
    }

    #[test]
    fn test_verify_invalid_range_proof_wrong_commitment() {
        let service = create_range_proof_service();
        let value1 = 2500u64;
        let value2 = 3000u64;

        let (crypto_proof1, _compressed_commitment1, _) =
            generate_valid_proof_and_commitment(value1);
        let (_crypto_proof2, compressed_commitment2, _) =
            generate_valid_proof_and_commitment(value2); // Different commitment

        let utxo = Utxo {
            output_hash: "wrong_commit_hash".to_string(),
            value: value1, // Proof is for value1
            block_height: 100,
            script_pubkey: "test_script_pubkey".to_string(),
            output_type: OutputType::Standard,
            proof: Some(UtxoRangeProof(crypto_proof1)), // Proof for value1
            commitment: compressed_commitment2,        // Commitment for value2
        };

        match verify_range_proof(&utxo, &service) {
            Err(TransactionError::CryptoError(_)) => { /* Expected */ }
            Ok(_) => panic!("Expected CryptoError for mismatched commitment"),
            Err(e) => panic!("Expected CryptoError, got {:?}", e),
        }
    }

    #[test]
    fn test_verify_invalid_range_proof_wrong_value() {
        let service = create_range_proof_service();
        let value_for_proof = 3500u64;
        let value_in_utxo = 4000u64; // Different value than what proof was made for

        let (crypto_proof, compressed_commitment, _) =
            generate_valid_proof_and_commitment(value_for_proof);

        let utxo = Utxo {
            output_hash: "wrong_value_hash".to_string(),
            value: value_in_utxo, // Utxo claims a different value
            block_height: 100,
            script_pubkey: "test_script_pubkey".to_string(),
            output_type: OutputType::Standard,
            proof: Some(UtxoRangeProof(crypto_proof)), // Proof is for 'value_for_proof'
            commitment: compressed_commitment,        // Commitment is for 'value_for_proof'
        };

        // This should fail because the statement passed to verify_batch will use value_in_utxo,
        // which doesn't match the value the proof was constructed for with the given commitment.
        match verify_range_proof(&utxo, &service) {
            Err(TransactionError::CryptoError(_)) => { /* Expected */ }
            Ok(_) => panic!("Expected CryptoError for mismatched value in statement"),
            Err(e) => panic!("Expected CryptoError, got {:?}", e),
        }
    }
}
